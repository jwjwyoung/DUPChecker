-----------0.92RC0 vs 2.0.5-alpha-rc2-----------
add: 4275, delete: 883, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------2.0.5-alpha-rc2 vs HADOOP-12111-moved-to-yetus-----------
  public void testSerializeAndDeserializeNull() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(null);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiate empty EnumSetWritable with no element type class providesd should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> nullFlagWritable = new EnumSetWritable<TestEnumSet>(
        null, TestEnumSet.class);

    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, nullFlagWritable, nullFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, null);
  }

+++++++++++++++++++++++
  public void testSerializeAndDeserializeNull() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(null);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception",
        gotException);

    EnumSetWritable<TestEnumSet> nullFlagWritable = 
        new EnumSetWritable<TestEnumSet>(null, TestEnumSet.class);

    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, nullFlagWritable, nullFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, null);
  }

  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiate empty EnumSetWritable with no element type class providesd should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = new EnumSetWritable<TestEnumSet>(
        emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
+++++++++++++++++++++++
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
add: 2856, delete: 485, change: 2284, unhandled: 0 size_exceptions: 263 size_serialize: 2
-----------HADOOP-12111-moved-to-yetus vs YARN-2928-2016-06-21-----------
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
+++++++++++++++++++++++
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
  @Test
add: 1075, delete: 223, change: 2098, unhandled: 0 size_exceptions: 106 size_serialize: 1
-----------YARN-2928-2016-06-21 vs YARN-2928-2016-07-08-----------
add: 59, delete: 40, change: 253, unhandled: 1 size_exceptions: 4 size_serialize: 0
-----------YARN-2928-2016-07-08 vs YARN-2928-2016-07-10-----------
add: 0, delete: 0, change: 88, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------YARN-2928-2016-07-10 vs YARN-5355-2016-11-06-----------
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8), name.length());
    xdr.writeInt(mode);
    objAttr.serialize(xdr);
  }
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8), name.length());
    xdr.writeInt(mode);
    objAttr.serialize(xdr);
  }
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.length());
    xdr.writeFixedOpaque(fromName.getBytes(Charsets.UTF_8), fromName.length());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.length());
    xdr.writeFixedOpaque(fromName.getBytes(StandardCharsets.UTF_8),
        fromName.length());
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
    objAttr.serialize(xdr);
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
    objAttr.serialize(xdr);
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8), name.length());
    objAttr.serialize(xdr);
    if (spec != null) {
      xdr.writeInt(spec.getSpecdata1());
      xdr.writeInt(spec.getSpecdata2());
    }
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8), name.length());
    objAttr.serialize(xdr);
    if (spec != null) {
      xdr.writeInt(spec.getSpecdata1());
      xdr.writeInt(spec.getSpecdata2());
    }
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(fromName.getBytes(Charsets.UTF_8));
    toDirHandle.serialize(xdr);
    xdr.writeInt(toName.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(toName.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(fromName.getBytes(StandardCharsets.UTF_8));
    toDirHandle.serialize(xdr);
    xdr.writeInt(toName.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(toName.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
    symAttr.serialize(xdr);
    xdr.writeInt(symData.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(symData.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
    symAttr.serialize(xdr);
    xdr.writeInt(symData.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(symData.getBytes(StandardCharsets.UTF_8));
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").getTextValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
+++++++++++++++++++++++
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").textValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
add: 324, delete: 106, change: 1357, unhandled: 0 size_exceptions: 59 size_serialize: 10
-----------YARN-5355-2016-11-06 vs YARN-5355-2017-04-25-----------
add: 366, delete: 138, change: 1506, unhandled: 0 size_exceptions: 49 size_serialize: 0
-----------YARN-5355-2017-04-25 vs YARN-5355-2017-08-31-----------
  public void testDeserializerNoData() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(false);
    Assert.assertEquals(0, serializer.deserializeKV(in, key, value));
  }

+++++++++++++++++++++++
  public void testDeserializerNoData() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(false);
    Assert.assertEquals(0, serializer.deserializeKV(in, key, value));
  }

  @Test
add: 437, delete: 33, change: 1714, unhandled: 0 size_exceptions: 38 size_serialize: 1
-----------YARN-5355-2017-08-31 vs YARN-5355-branch-2-2016-11-06-----------
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").textValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
+++++++++++++++++++++++
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").getTextValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
add: 313, delete: 1251, change: 2661, unhandled: 2 size_exceptions: 88 size_serialize: 1
-----------YARN-5355-branch-2-2016-11-06 vs YARN-5355-branch-2-2017-04-25-----------
add: 337, delete: 102, change: 1062, unhandled: 0 size_exceptions: 21 size_serialize: 0
-----------YARN-5355-branch-2-2017-04-25 vs YARN-5355_branch2-2017-08-31-----------
add: 169, delete: 18, change: 1237, unhandled: 0 size_exceptions: 36 size_serialize: 0
-----------YARN-5355_branch2-2017-08-31 vs YARN-5355_branch2-2017-10-14-----------
add: 337, delete: 7, change: 471, unhandled: 0 size_exceptions: 15 size_serialize: 0
-----------YARN-5355_branch2-2017-10-14 vs YARN-5355_branch2-2017-10-17-----------
add: 3, delete: 1, change: 81, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------YARN-5355_branch2-2017-10-17 vs YARN-7055-2018-03-02-----------
  public boolean deserialize(XDR xdr) {
    if (!XDR.verifyLength(xdr, 32)) {
      return false;
    }
    int size = xdr.readInt();
    handle = xdr.readFixedOpaque(size);
    fileId = bytesToLong(handle);
    return true;
  }
  
+++++++++++++++++++++++
  public boolean deserialize(XDR xdr) {
    if (!XDR.verifyLength(xdr, 32)) {
      return false;
    }
    int size = xdr.readInt();
    handle = xdr.readFixedOpaque(size);
    fileId = bytesToLong(handle, 0);
    namenodeId = bytesToInt(handle, 8);
    return true;
  }
  
  private Set<ReportForJson> getAndDeserializeJson()
      throws IOException {
    final String json = tracker.getJson();
    LOG.info("Got JSON: {}", json);
    return (new ObjectMapper()).readValue(
        json, new TypeReference<Set<ReportForJson>>() {});
+++++++++++++++++++++++
  private Set<ReportForJson> getAndDeserializeJson()
      throws IOException {
    final String json = tracker.getJson();
    LOG.info("Got JSON: {}", json);
    return READER.readValue(json);
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").getTextValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
+++++++++++++++++++++++
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").textValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
add: 1564, delete: 383, change: 2598, unhandled: 1 size_exceptions: 113 size_serialize: 3
-----------YARN-7055-2018-03-02 vs branch-0.20.203.0-rc0-----------
add: 1843, delete: 9328, change: 0, unhandled: 5 size_exceptions: 0 size_serialize: 0
-----------branch-0.20.203.0-rc0 vs branch-2.0.6-alpha-rc0-----------
add: 4275, delete: 1843, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------branch-2.0.6-alpha-rc0 vs feature_YARN-2928-2015-11-09-----------
  public void testSerializeAndDeserializeNull() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(null);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiate empty EnumSetWritable with no element type class providesd should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> nullFlagWritable = new EnumSetWritable<TestEnumSet>(
        null, TestEnumSet.class);

    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, nullFlagWritable, nullFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, null);
  }

+++++++++++++++++++++++
  public void testSerializeAndDeserializeNull() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(null);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception",
        gotException);

    EnumSetWritable<TestEnumSet> nullFlagWritable = 
        new EnumSetWritable<TestEnumSet>(null, TestEnumSet.class);

    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, nullFlagWritable, nullFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, null);
  }

  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiate empty EnumSetWritable with no element type class providesd should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = new EnumSetWritable<TestEnumSet>(
        emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
+++++++++++++++++++++++
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
add: 3318, delete: 542, change: 2302, unhandled: 0 size_exceptions: 260 size_serialize: 2
-----------feature_YARN-2928-2015-11-09 vs feature_YARN-2928-2016-01-20-----------
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
+++++++++++++++++++++++
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
  @Test
add: 114, delete: 31, change: 883, unhandled: 0 size_exceptions: 28 size_serialize: 1
-----------feature_YARN-2928-2016-01-20 vs feature_YARN-2928_2015-08-24-----------
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
  @Test
+++++++++++++++++++++++
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
add: 148, delete: 498, change: 1493, unhandled: 0 size_exceptions: 40 size_serialize: 1
-----------feature_YARN-2928_2015-08-24 vs ozone-0.2.1-alpha-RC0-----------
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
+++++++++++++++++++++++
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
  @Test
  public boolean deserialize(XDR xdr) {
    if (!XDR.verifyLength(xdr, 32)) {
      return false;
    }
    int size = xdr.readInt();
    handle = xdr.readFixedOpaque(size);
    fileId = bytesToLong(handle);
    return true;
  }
  
+++++++++++++++++++++++
  public boolean deserialize(XDR xdr) {
    if (!XDR.verifyLength(xdr, 32)) {
      return false;
    }
    int size = xdr.readInt();
    handle = xdr.readFixedOpaque(size);
    fileId = bytesToLong(handle, 0);
    namenodeId = bytesToInt(handle, 8);
    return true;
  }
  
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8), name.length());
    xdr.writeInt(mode);
    objAttr.serialize(xdr);
  }
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8), name.length());
    xdr.writeInt(mode);
    objAttr.serialize(xdr);
  }
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.length());
    xdr.writeFixedOpaque(fromName.getBytes(Charsets.UTF_8), fromName.length());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.length());
    xdr.writeFixedOpaque(fromName.getBytes(StandardCharsets.UTF_8),
        fromName.length());
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
    objAttr.serialize(xdr);
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
    objAttr.serialize(xdr);
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8), name.length());
    objAttr.serialize(xdr);
    if (spec != null) {
      xdr.writeInt(spec.getSpecdata1());
      xdr.writeInt(spec.getSpecdata2());
    }
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8), name.length());
    objAttr.serialize(xdr);
    if (spec != null) {
      xdr.writeInt(spec.getSpecdata1());
      xdr.writeInt(spec.getSpecdata2());
    }
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(fromName.getBytes(Charsets.UTF_8));
    toDirHandle.serialize(xdr);
    xdr.writeInt(toName.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(toName.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(fromName.getBytes(StandardCharsets.UTF_8));
    toDirHandle.serialize(xdr);
    xdr.writeInt(toName.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(toName.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
    symAttr.serialize(xdr);
    xdr.writeInt(symData.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(symData.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
    symAttr.serialize(xdr);
    xdr.writeInt(symData.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(symData.getBytes(StandardCharsets.UTF_8));
  public void testDeserializerNoData() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(false);
    Assert.assertEquals(0, serializer.deserializeKV(in, key, value));
  }

+++++++++++++++++++++++
  public void testDeserializerNoData() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(false);
    Assert.assertEquals(0, serializer.deserializeKV(in, key, value));
  }

  @Test
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").getTextValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
+++++++++++++++++++++++
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").textValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
add: 4081, delete: 395, change: 3568, unhandled: 10 size_exceptions: 237 size_serialize: 13
-----------ozone-0.2.1-alpha-RC0 vs ozone-0.3.0-alpha-----------
  private Map<String, String> deserializeMap(FSDataInputStream fis)
      throws IOException {
    ObjectInput oi = new ObjectInputStream(fis);
    Map<String, String> newMap = null;
    try {
      newMap = (Map<String, String>) oi.readObject();
    } catch (ClassNotFoundException e) {
      throw new IOException(e);
    }
    return newMap;
  }

+++++++++++++++++++++++
  private Map<String, String> deserializeMap(FSDataInputStream fis)
      throws IOException {
    ObjectInput oi = new ObjectInputStream(fis);
    Map<String, String> newMap;
    try {
      newMap = (Map<String, String>) oi.readObject();
    } catch (ClassNotFoundException e) {
      throw new IOException(e);
    }
    return newMap;
  }

add: 390, delete: 22, change: 687, unhandled: 1 size_exceptions: 25 size_serialize: 1
-----------ozone-0.3.0-alpha vs ozone-0.3.0-alpha-RC0-----------
add: 0, delete: 0, change: 2, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------ozone-0.3.0-alpha-RC0 vs ozone-0.3.0-alpha-RC1-----------
add: 0, delete: 0, change: 2, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------ozone-0.3.0-alpha-RC1 vs ozone-0.4.0-alpha-RC0-----------
  public void testDeserializer() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(true);
    Assert.assertTrue(serializer.deserializeKV(in, key, value) > 0);

    Mockito.verify(in, Mockito.times(4)).readInt();
    Mockito.verify(in, Mockito.times(2)).readFully(Matchers.any(byte[].class),
                                                   Matchers.anyInt(), Matchers.anyInt());
+++++++++++++++++++++++
  public void testDeserializer() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(true);
    Assert.assertTrue(serializer.deserializeKV(in, key, value) > 0);

    Mockito.verify(in, Mockito.times(4)).readInt();
    Mockito.verify(in, Mockito.times(2)).readFully(any(byte[].class),
        anyInt(), anyInt());
  public static Map<String, String> deserializeAclSpec(final String aclSpecString) {
    final Map<String, String> aclEntries  = new HashMap<>();
    final String[] aclArray = aclSpecString.split(AbfsHttpConstants.COMMA);
    for (String acl : aclArray) {
      int idx = acl.lastIndexOf(AbfsHttpConstants.COLON);
      aclEntries.put(acl.substring(0, idx), acl.substring(idx + 1));
    }
    return aclEntries;
  }

+++++++++++++++++++++++
  public static Map<String, String> deserializeAclSpec(final String aclSpecString) throws AzureBlobFileSystemException {
    final Map<String, String> aclEntries  = new HashMap<>();
    final String[] aceArray = aclSpecString.split(AbfsHttpConstants.COMMA);
    for (String ace : aceArray) {
      int idx = ace.lastIndexOf(AbfsHttpConstants.COLON);
      final String key = ace.substring(0, idx);
      final String val = ace.substring(idx + 1);
      if (aclEntries.containsKey(key)) {
        throw new InvalidAclOperationException("Duplicate acl entries are not allowed.");
      }
      aclEntries.put(key, val);
    }
    return aclEntries;
  }

add: 851, delete: 181, change: 1985, unhandled: 2 size_exceptions: 129 size_serialize: 2
-----------ozone-0.4.0-alpha-RC0 vs ozone-0.4.0-alpha-RC1-----------
add: 0, delete: 0, change: 1, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------ozone-0.4.0-alpha-RC1 vs ozone-0.4.0-alpha-RC2-----------
add: 1, delete: 0, change: 3, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------ozone-0.4.0-alpha-RC2 vs ozone-0.4.1-alpha-----------
  protected static void serializeAndDeserializePolicyManager(
      FederationPolicyManager wfp, Class policyManagerType,
      Class expAMRMProxyPolicy, Class expRouterPolicy) throws Exception {

    // serializeConf it in a context
    SubClusterPolicyConfiguration fpc = wfp.serializeConf();
    fpc.setType(policyManagerType.getCanonicalName());
    FederationPolicyInitializationContext context =
        new FederationPolicyInitializationContext();
    context.setSubClusterPolicyConfiguration(fpc);
    context
        .setFederationStateStoreFacade(FederationPoliciesTestUtil.initFacade());
    context.setFederationSubclusterResolver(
        FederationPoliciesTestUtil.initResolver());
    context.setHomeSubcluster(SubClusterId.newInstance("homesubcluster"));

    // based on the "context" created instantiate new class and use it
    Class c = Class.forName(wfp.getClass().getCanonicalName());
    FederationPolicyManager wfp2 = (FederationPolicyManager) c.newInstance();

    FederationAMRMProxyPolicy federationAMRMProxyPolicy =
        wfp2.getAMRMPolicy(context, null);

    FederationRouterPolicy federationRouterPolicy =
        wfp2.getRouterPolicy(context, null);

    Assert.assertEquals(federationAMRMProxyPolicy.getClass(),
        expAMRMProxyPolicy);

    Assert.assertEquals(federationRouterPolicy.getClass(), expRouterPolicy);
  }
+++++++++++++++++++++++
  protected static void serializeAndDeserializePolicyManager(
      FederationPolicyManager wfp, Class policyManagerType,
      Class expAMRMProxyPolicy, Class expRouterPolicy) throws Exception {

    // serializeConf it in a context
    SubClusterPolicyConfiguration fpc = wfp.serializeConf();
    fpc.setType(policyManagerType.getCanonicalName());
    FederationPolicyInitializationContext context =
        new FederationPolicyInitializationContext();
    context.setSubClusterPolicyConfiguration(fpc);
    context
        .setFederationStateStoreFacade(FederationPoliciesTestUtil.initFacade());
    context.setFederationSubclusterResolver(
        FederationPoliciesTestUtil.initResolver());
    context.setHomeSubcluster(SubClusterId.newInstance("homesubcluster"));

    // based on the "context" created instantiate new class and use it
    Class c = Class.forName(wfp.getClass().getCanonicalName());
    FederationPolicyManager wfp2 = (FederationPolicyManager) c.newInstance();

    FederationAMRMProxyPolicy federationAMRMProxyPolicy =
        wfp2.getAMRMPolicy(context, null);

    FederationRouterPolicy federationRouterPolicy =
        wfp2.getRouterPolicy(context, null);

    assertThat(federationAMRMProxyPolicy).
        isExactlyInstanceOf(expAMRMProxyPolicy);

    assertThat(federationRouterPolicy).isExactlyInstanceOf(expRouterPolicy);
  }
add: 832, delete: 55, change: 1499, unhandled: 2 size_exceptions: 62 size_serialize: 1
-----------ozone-0.4.1-alpha vs ozone-0.4.1-alpha-RC0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------ozone-0.4.1-alpha-RC0 vs rel/release------------
  public boolean deserialize(XDR xdr) {
    if (!XDR.verifyLength(xdr, 32)) {
      return false;
    }
    int size = xdr.readInt();
    handle = xdr.readFixedOpaque(size);
    fileId = bytesToLong(handle, 0);
    namenodeId = bytesToInt(handle, 8);
    return true;
  }
  
+++++++++++++++++++++++
  public boolean deserialize(XDR xdr) {
    if (!XDR.verifyLength(xdr, 32)) {
      return false;
    }
    int size = xdr.readInt();
    handle = xdr.readFixedOpaque(size);
    fileId = bytesToLong(handle);
    return true;
  }
  
  private Set<ReportForJson> getAndDeserializeJson()
      throws IOException {
    final String json = tracker.getJson();
    LOG.info("Got JSON: {}", json);
    return READER.readValue(json);
+++++++++++++++++++++++
  private Set<ReportForJson> getAndDeserializeJson()
      throws IOException {
    final String json = tracker.getJson();
    LOG.info("Got JSON: {}", json);
    return (new ObjectMapper()).readValue(
        json, new TypeReference<Set<ReportForJson>>() {});
  public void testDeserializer() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(true);
    Assert.assertTrue(serializer.deserializeKV(in, key, value) > 0);

    Mockito.verify(in, Mockito.times(4)).readInt();
    Mockito.verify(in, Mockito.times(2)).readFully(any(byte[].class),
        anyInt(), anyInt());
+++++++++++++++++++++++
  public void testDeserializer() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(true);
    Assert.assertTrue(serializer.deserializeKV(in, key, value) > 0);

    Mockito.verify(in, Mockito.times(4)).readInt();
    Mockito.verify(in, Mockito.times(2)).readFully(Matchers.any(byte[].class),
                                                   Matchers.anyInt(), Matchers.anyInt());
  protected static void serializeAndDeserializePolicyManager(
      FederationPolicyManager wfp, Class policyManagerType,
      Class expAMRMProxyPolicy, Class expRouterPolicy) throws Exception {

    // serializeConf it in a context
    SubClusterPolicyConfiguration fpc = wfp.serializeConf();
    fpc.setType(policyManagerType.getCanonicalName());
    FederationPolicyInitializationContext context =
        new FederationPolicyInitializationContext();
    context.setSubClusterPolicyConfiguration(fpc);
    context
        .setFederationStateStoreFacade(FederationPoliciesTestUtil.initFacade());
    context.setFederationSubclusterResolver(
        FederationPoliciesTestUtil.initResolver());
    context.setHomeSubcluster(SubClusterId.newInstance("homesubcluster"));

    // based on the "context" created instantiate new class and use it
    Class c = Class.forName(wfp.getClass().getCanonicalName());
    FederationPolicyManager wfp2 = (FederationPolicyManager) c.newInstance();

    FederationAMRMProxyPolicy federationAMRMProxyPolicy =
        wfp2.getAMRMPolicy(context, null);

    FederationRouterPolicy federationRouterPolicy =
        wfp2.getRouterPolicy(context, null);

    assertThat(federationAMRMProxyPolicy).
        isExactlyInstanceOf(expAMRMProxyPolicy);

    assertThat(federationRouterPolicy).isExactlyInstanceOf(expRouterPolicy);
  }
+++++++++++++++++++++++
  protected static void serializeAndDeserializePolicyManager(
      FederationPolicyManager wfp, Class policyManagerType,
      Class expAMRMProxyPolicy, Class expRouterPolicy) throws Exception {

    // serializeConf it in a context
    SubClusterPolicyConfiguration fpc = wfp.serializeConf();
    fpc.setType(policyManagerType.getCanonicalName());
    FederationPolicyInitializationContext context =
        new FederationPolicyInitializationContext();
    context.setSubClusterPolicyConfiguration(fpc);
    context
        .setFederationStateStoreFacade(FederationPoliciesTestUtil.initFacade());
    context.setFederationSubclusterResolver(
        FederationPoliciesTestUtil.initResolver());
    context.setHomeSubcluster(SubClusterId.newInstance("homesubcluster"));

    // based on the "context" created instantiate new class and use it
    Class c = Class.forName(wfp.getClass().getCanonicalName());
    FederationPolicyManager wfp2 = (FederationPolicyManager) c.newInstance();

    FederationAMRMProxyPolicy federationAMRMProxyPolicy =
        wfp2.getAMRMPolicy(context, null);

    FederationRouterPolicy federationRouterPolicy =
        wfp2.getRouterPolicy(context, null);

    Assert.assertEquals(federationAMRMProxyPolicy.getClass(),
        expAMRMProxyPolicy);

    Assert.assertEquals(federationRouterPolicy.getClass(), expRouterPolicy);
  }
add: 381, delete: 3933, change: 2936, unhandled: 11 size_exceptions: 177 size_serialize: 4
-----------rel/release- vs rel/release-2.6.4-----------
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
  @Test
+++++++++++++++++++++++
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
  public static Nfs3FileAttributes deserialize(XDR xdr) {
    Nfs3FileAttributes attr = new Nfs3FileAttributes();
    attr.type = xdr.readInt();
    attr.mode = xdr.readInt();
    attr.nlink = xdr.readInt();
    attr.uid = xdr.readInt();
    attr.gid = xdr.readInt();
    attr.size = xdr.readHyper();
    attr.used = xdr.readHyper();
    attr.rdev = new Specdata3(xdr.readInt(), xdr.readInt());
    attr.fsid = xdr.readHyper();
    attr.fileId = xdr.readHyper();
    attr.atime = NfsTime.deserialize(xdr);
    attr.mtime = NfsTime.deserialize(xdr);
    attr.ctime = NfsTime.deserialize(xdr);
    return attr;
  }
  
  @Override
+++++++++++++++++++++++
  public static Nfs3FileAttributes deserialize(XDR xdr) {
    Nfs3FileAttributes attr = new Nfs3FileAttributes();
    attr.type = xdr.readInt();
    attr.mode = xdr.readInt();
    attr.nlink = xdr.readInt();
    attr.uid = xdr.readInt();
    attr.gid = xdr.readInt();
    attr.size = xdr.readHyper();
    attr.used = xdr.readHyper();
    // Ignore rdev
    xdr.readInt();
    xdr.readInt();
    attr.rdev = new Specdata3();
    attr.fsid = xdr.readHyper();
    attr.fileId = xdr.readHyper();
    attr.atime = NfsTime.deserialize(xdr);
    attr.mtime = NfsTime.deserialize(xdr);
    attr.ctime = NfsTime.deserialize(xdr);
    return attr;
  }
  
  @Override
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8), name.length());
    xdr.writeInt(mode);
    objAttr.serialize(xdr);
  }
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(), name.length());
    xdr.writeInt(mode);
    objAttr.serialize(xdr);
  }
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.length());
    xdr.writeFixedOpaque(fromName.getBytes(StandardCharsets.UTF_8),
        fromName.length());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.length());
    xdr.writeFixedOpaque(fromName.getBytes(), fromName.length());
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
    objAttr.serialize(xdr);
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
    objAttr.serialize(xdr);
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8), name.length());
    objAttr.serialize(xdr);
    if (spec != null) {
      xdr.writeInt(spec.getSpecdata1());
      xdr.writeInt(spec.getSpecdata2());
    }
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(), name.length());
    objAttr.serialize(xdr);
    if (spec != null) {
      xdr.writeInt(spec.getSpecdata1());
      xdr.writeInt(spec.getSpecdata2());
    }
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
  public void serialize(XDR xdr) {
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(fromName.getBytes(StandardCharsets.UTF_8));
    toDirHandle.serialize(xdr);
    xdr.writeInt(toName.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(toName.getBytes(StandardCharsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.getBytes().length);
    xdr.writeFixedOpaque(fromName.getBytes());
    toDirHandle.serialize(xdr);
    xdr.writeInt(toName.getBytes().length);
    xdr.writeFixedOpaque(toName.getBytes());
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
    symAttr.serialize(xdr);
    xdr.writeInt(symData.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(symData.getBytes(StandardCharsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
    symAttr.serialize(xdr);
    xdr.writeInt(symData.getBytes().length);
    xdr.writeFixedOpaque(symData.getBytes());
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").textValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
+++++++++++++++++++++++
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").getTextValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
add: 533, delete: 3235, change: 3237, unhandled: 3 size_exceptions: 276 size_serialize: 12
-----------rel/release-2.6.4 vs rel/release-2.6.5-----------
add: 3, delete: 0, change: 123, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------rel/release-2.6.5 vs rel/release-2.7.2-----------
  public static Nfs3FileAttributes deserialize(XDR xdr) {
    Nfs3FileAttributes attr = new Nfs3FileAttributes();
    attr.type = xdr.readInt();
    attr.mode = xdr.readInt();
    attr.nlink = xdr.readInt();
    attr.uid = xdr.readInt();
    attr.gid = xdr.readInt();
    attr.size = xdr.readHyper();
    attr.used = xdr.readHyper();
    // Ignore rdev
    xdr.readInt();
    xdr.readInt();
    attr.rdev = new Specdata3();
    attr.fsid = xdr.readHyper();
    attr.fileId = xdr.readHyper();
    attr.atime = NfsTime.deserialize(xdr);
    attr.mtime = NfsTime.deserialize(xdr);
    attr.ctime = NfsTime.deserialize(xdr);
    return attr;
  }
  
  @Override
+++++++++++++++++++++++
  public static Nfs3FileAttributes deserialize(XDR xdr) {
    Nfs3FileAttributes attr = new Nfs3FileAttributes();
    attr.type = xdr.readInt();
    attr.mode = xdr.readInt();
    attr.nlink = xdr.readInt();
    attr.uid = xdr.readInt();
    attr.gid = xdr.readInt();
    attr.size = xdr.readHyper();
    attr.used = xdr.readHyper();
    attr.rdev = new Specdata3(xdr.readInt(), xdr.readInt());
    attr.fsid = xdr.readHyper();
    attr.fileId = xdr.readHyper();
    attr.atime = NfsTime.deserialize(xdr);
    attr.mtime = NfsTime.deserialize(xdr);
    attr.ctime = NfsTime.deserialize(xdr);
    return attr;
  }
  
  @Override
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(), name.length());
    xdr.writeInt(mode);
    objAttr.serialize(xdr);
  }
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8), name.length());
    xdr.writeInt(mode);
    objAttr.serialize(xdr);
  }
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.length());
    xdr.writeFixedOpaque(fromName.getBytes(), fromName.length());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.length());
    xdr.writeFixedOpaque(fromName.getBytes(Charsets.UTF_8), fromName.length());
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
    objAttr.serialize(xdr);
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
    objAttr.serialize(xdr);
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(), name.length());
    objAttr.serialize(xdr);
    if (spec != null) {
      xdr.writeInt(spec.getSpecdata1());
      xdr.writeInt(spec.getSpecdata2());
    }
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8), name.length());
    objAttr.serialize(xdr);
    if (spec != null) {
      xdr.writeInt(spec.getSpecdata1());
      xdr.writeInt(spec.getSpecdata2());
    }
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
  public void serialize(XDR xdr) {
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.getBytes().length);
    xdr.writeFixedOpaque(fromName.getBytes());
    toDirHandle.serialize(xdr);
    xdr.writeInt(toName.getBytes().length);
    xdr.writeFixedOpaque(toName.getBytes());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(fromName.getBytes(Charsets.UTF_8));
    toDirHandle.serialize(xdr);
    xdr.writeInt(toName.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(toName.getBytes(Charsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
    symAttr.serialize(xdr);
    xdr.writeInt(symData.getBytes().length);
    xdr.writeFixedOpaque(symData.getBytes());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
    symAttr.serialize(xdr);
    xdr.writeInt(symData.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(symData.getBytes(Charsets.UTF_8));
add: 356, delete: 48, change: 1500, unhandled: 0 size_exceptions: 109 size_serialize: 10
-----------rel/release-2.7.2 vs rel/release-2.7.3-----------
add: 5, delete: 0, change: 337, unhandled: 0 size_exceptions: 6 size_serialize: 0
-----------rel/release-2.7.3 vs rel/release-2.7.4-----------
add: 25, delete: 1, change: 343, unhandled: 0 size_exceptions: 5 size_serialize: 0
-----------rel/release-2.7.4 vs rel/release-2.7.5-----------
add: 4, delete: 0, change: 74, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------rel/release-2.7.5 vs rel/release-2.7.6-----------
add: 5, delete: 3, change: 72, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------rel/release-2.7.6 vs rel/release-2.7.7-----------
add: 0, delete: 0, change: 18, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------rel/release-2.7.7 vs rel/release-2.8.0-----------
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
+++++++++++++++++++++++
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
  @Test
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8), name.length());
    xdr.writeInt(mode);
    objAttr.serialize(xdr);
  }
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8), name.length());
    xdr.writeInt(mode);
    objAttr.serialize(xdr);
  }
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.length());
    xdr.writeFixedOpaque(fromName.getBytes(Charsets.UTF_8), fromName.length());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.length());
    xdr.writeFixedOpaque(fromName.getBytes(StandardCharsets.UTF_8),
        fromName.length());
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
    objAttr.serialize(xdr);
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
    objAttr.serialize(xdr);
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8), name.length());
    objAttr.serialize(xdr);
    if (spec != null) {
      xdr.writeInt(spec.getSpecdata1());
      xdr.writeInt(spec.getSpecdata2());
    }
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8), name.length());
    objAttr.serialize(xdr);
    if (spec != null) {
      xdr.writeInt(spec.getSpecdata1());
      xdr.writeInt(spec.getSpecdata2());
    }
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(fromName.getBytes(Charsets.UTF_8));
    toDirHandle.serialize(xdr);
    xdr.writeInt(toName.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(toName.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(fromName.getBytes(StandardCharsets.UTF_8));
    toDirHandle.serialize(xdr);
    xdr.writeInt(toName.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(toName.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
    symAttr.serialize(xdr);
    xdr.writeInt(symData.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(symData.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
    symAttr.serialize(xdr);
    xdr.writeInt(symData.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(symData.getBytes(StandardCharsets.UTF_8));
  public void testDeserializeHAToken() throws IOException {
    Configuration conf = DFSTestUtil.newHAConfiguration(LOGICAL_NAME);
    final Token<DelegationTokenIdentifier> token = new
        Token<DelegationTokenIdentifier>();
    QueryStringDecoder decoder = new QueryStringDecoder(
      WebHdfsHandler.WEBHDFS_PREFIX + "/?"
      + NamenodeAddressParam.NAME + "=" + LOGICAL_NAME + "&"
      + DelegationParam.NAME + "=" + token.encodeToUrlString());
    ParameterParser testParser = new ParameterParser(decoder, conf);
    final Token<DelegationTokenIdentifier> tok2 = testParser.delegationToken();
    Assert.assertTrue(HAUtil.isTokenForLogicalUri(tok2));
  }

  @Test
+++++++++++++++++++++++
  public void testDeserializeHAToken() throws IOException {
    Configuration conf = DFSTestUtil.newHAConfiguration(LOGICAL_NAME);
    final Token<DelegationTokenIdentifier> token = new
        Token<DelegationTokenIdentifier>();
    QueryStringDecoder decoder = new QueryStringDecoder(
      WebHdfsHandler.WEBHDFS_PREFIX + "/?"
      + NamenodeAddressParam.NAME + "=" + LOGICAL_NAME + "&"
      + DelegationParam.NAME + "=" + token.encodeToUrlString());
    ParameterParser testParser = new ParameterParser(decoder, conf);
    final Token<DelegationTokenIdentifier> tok2 = testParser.delegationToken();
    Assert.assertTrue(HAUtilClient.isTokenForLogicalUri(tok2));
  }

  @Test
add: 1023, delete: 298, change: 2320, unhandled: 0 size_exceptions: 119 size_serialize: 11
-----------rel/release-2.8.0 vs rel/release-2.8.1-----------
add: 0, delete: 0, change: 2, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------rel/release-2.8.1 vs rel/release-2.8.2-----------
add: 33, delete: 6, change: 516, unhandled: 0 size_exceptions: 12 size_serialize: 0
-----------rel/release-2.8.2 vs rel/release-2.8.3-----------
add: 8, delete: 0, change: 155, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------rel/release-2.8.3 vs rel/release-2.8.4-----------
add: 5, delete: 4, change: 180, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------rel/release-2.8.4 vs rel/release-2.8.5-----------
add: 3, delete: 0, change: 48, unhandled: 0 size_exceptions: 6 size_serialize: 0
-----------rel/release-2.8.5 vs rel/release-2.9.0-----------
add: 1339, delete: 78, change: 1920, unhandled: 0 size_exceptions: 74 size_serialize: 0
-----------rel/release-2.9.0 vs rel/release-2.9.1-----------
add: 281, delete: 154, change: 242, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------rel/release-2.9.1 vs rel/release-2.9.2-----------
add: 33, delete: 1, change: 297, unhandled: 0 size_exceptions: 11 size_serialize: 0
-----------rel/release-2.9.2 vs rel/release-2.10.0-----------
add: 439, delete: 96, change: 728, unhandled: 0 size_exceptions: 32 size_serialize: 0
-----------rel/release-2.10.0 vs rel/release-3.0.0-----------
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").getTextValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
+++++++++++++++++++++++
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").textValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
add: 753, delete: 924, change: 2428, unhandled: 1 size_exceptions: 75 size_serialize: 1
-----------rel/release-3.0.0 vs rel/release-3.0.0-alpha1-----------
  public void testDeserializerNoData() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(false);
    Assert.assertEquals(0, serializer.deserializeKV(in, key, value));
  }

  @Test
+++++++++++++++++++++++
  public void testDeserializerNoData() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(false);
    Assert.assertEquals(0, serializer.deserializeKV(in, key, value));
  }

  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").textValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
+++++++++++++++++++++++
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").getTextValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
add: 268, delete: 1398, change: 2897, unhandled: 0 size_exceptions: 132 size_serialize: 2
-----------rel/release-3.0.0-alpha1 vs rel/release-3.0.0-alpha2-----------
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").getTextValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
+++++++++++++++++++++++
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").textValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
add: 406, delete: 162, change: 1556, unhandled: 0 size_exceptions: 48 size_serialize: 1
-----------rel/release-3.0.0-alpha2 vs rel/release-3.0.0-alpha3-----------
add: 0, delete: 0, change: 2, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------rel/release-3.0.0-alpha3 vs rel/release-3.0.0-alpha4-----------
add: 238, delete: 45, change: 1392, unhandled: 0 size_exceptions: 54 size_serialize: 0
-----------rel/release-3.0.0-alpha4 vs rel/release-3.0.0-beta1-----------
  public void testDeserializerNoData() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(false);
    Assert.assertEquals(0, serializer.deserializeKV(in, key, value));
  }

+++++++++++++++++++++++
  public void testDeserializerNoData() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(false);
    Assert.assertEquals(0, serializer.deserializeKV(in, key, value));
  }

  @Test
add: 465, delete: 82, change: 1464, unhandled: 2 size_exceptions: 31 size_serialize: 1
-----------rel/release-3.0.0-beta1 vs rel/release-3.0.1-----------
add: 376, delete: 18, change: 967, unhandled: 2 size_exceptions: 73 size_serialize: 0
-----------rel/release-3.0.1 vs rel/release-3.0.2-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------rel/release-3.0.2 vs rel/release-3.0.3-----------
add: 287, delete: 200, change: 350, unhandled: 1 size_exceptions: 13 size_serialize: 0
-----------rel/release-3.0.3 vs rel/release-3.1.0-----------
  public boolean deserialize(XDR xdr) {
    if (!XDR.verifyLength(xdr, 32)) {
      return false;
    }
    int size = xdr.readInt();
    handle = xdr.readFixedOpaque(size);
    fileId = bytesToLong(handle);
    return true;
  }
  
+++++++++++++++++++++++
  public boolean deserialize(XDR xdr) {
    if (!XDR.verifyLength(xdr, 32)) {
      return false;
    }
    int size = xdr.readInt();
    handle = xdr.readFixedOpaque(size);
    fileId = bytesToLong(handle, 0);
    namenodeId = bytesToInt(handle, 8);
    return true;
  }
  
  private Set<ReportForJson> getAndDeserializeJson()
      throws IOException {
    final String json = tracker.getJson();
    LOG.info("Got JSON: {}", json);
    return (new ObjectMapper()).readValue(
        json, new TypeReference<Set<ReportForJson>>() {});
+++++++++++++++++++++++
  private Set<ReportForJson> getAndDeserializeJson()
      throws IOException {
    final String json = tracker.getJson();
    LOG.info("Got JSON: {}", json);
    return READER.readValue(json);
add: 673, delete: 150, change: 1157, unhandled: 2 size_exceptions: 62 size_serialize: 2
-----------rel/release-3.1.0 vs rel/release-3.1.1-----------
add: 113, delete: 18, change: 676, unhandled: 2 size_exceptions: 32 size_serialize: 0
-----------rel/release-3.1.1 vs rel/release-3.1.2-----------
add: 52, delete: 5, change: 551, unhandled: 0 size_exceptions: 39 size_serialize: 0
-----------rel/release-3.1.2 vs rel/release-3.1.3-----------
add: 55, delete: 1, change: 506, unhandled: 3 size_exceptions: 5 size_serialize: 0
-----------rel/release-3.1.3 vs rel/release-3.2.0-----------
add: 438, delete: 84, change: 1611, unhandled: 3 size_exceptions: 46 size_serialize: 0
-----------rel/release-3.2.0 vs rel/release-3.2.1-----------
  public static Map<String, String> deserializeAclSpec(final String aclSpecString) {
    final Map<String, String> aclEntries  = new HashMap<>();
    final String[] aclArray = aclSpecString.split(AbfsHttpConstants.COMMA);
    for (String acl : aclArray) {
      int idx = acl.lastIndexOf(AbfsHttpConstants.COLON);
      aclEntries.put(acl.substring(0, idx), acl.substring(idx + 1));
    }
    return aclEntries;
  }

+++++++++++++++++++++++
  public static Map<String, String> deserializeAclSpec(final String aclSpecString) throws AzureBlobFileSystemException {
    final Map<String, String> aclEntries  = new HashMap<>();
    final String[] aceArray = aclSpecString.split(AbfsHttpConstants.COMMA);
    for (String ace : aceArray) {
      int idx = ace.lastIndexOf(AbfsHttpConstants.COLON);
      final String key = ace.substring(0, idx);
      final String val = ace.substring(idx + 1);
      if (aclEntries.containsKey(key)) {
        throw new InvalidAclOperationException("Duplicate acl entries are not allowed.");
      }
      aclEntries.put(key, val);
    }
    return aclEntries;
  }

add: 123, delete: 9, change: 787, unhandled: 3 size_exceptions: 34 size_serialize: 1
-----------rel/release-3.2.1 vs rel/release-X.Y.Z-----------
  public boolean deserialize(XDR xdr) {
    if (!XDR.verifyLength(xdr, 32)) {
      return false;
    }
    int size = xdr.readInt();
    handle = xdr.readFixedOpaque(size);
    fileId = bytesToLong(handle, 0);
    namenodeId = bytesToInt(handle, 8);
    return true;
  }
  
+++++++++++++++++++++++
  public boolean deserialize(XDR xdr) {
    if (!XDR.verifyLength(xdr, 32)) {
      return false;
    }
    int size = xdr.readInt();
    handle = xdr.readFixedOpaque(size);
    fileId = bytesToLong(handle);
    return true;
  }
  
  private Set<ReportForJson> getAndDeserializeJson()
      throws IOException {
    final String json = tracker.getJson();
    LOG.info("Got JSON: {}", json);
    return READER.readValue(json);
+++++++++++++++++++++++
  private Set<ReportForJson> getAndDeserializeJson()
      throws IOException {
    final String json = tracker.getJson();
    LOG.info("Got JSON: {}", json);
    return (new ObjectMapper()).readValue(
        json, new TypeReference<Set<ReportForJson>>() {});
add: 127, delete: 1314, change: 2304, unhandled: 3 size_exceptions: 122 size_serialize: 2
-----------rel/release-X.Y.Z vs rel/submarine-0.2.0-----------
  public boolean deserialize(XDR xdr) {
    if (!XDR.verifyLength(xdr, 32)) {
      return false;
    }
    int size = xdr.readInt();
    handle = xdr.readFixedOpaque(size);
    fileId = bytesToLong(handle);
    return true;
  }
  
+++++++++++++++++++++++
  public boolean deserialize(XDR xdr) {
    if (!XDR.verifyLength(xdr, 32)) {
      return false;
    }
    int size = xdr.readInt();
    handle = xdr.readFixedOpaque(size);
    fileId = bytesToLong(handle, 0);
    namenodeId = bytesToInt(handle, 8);
    return true;
  }
  
  private Set<ReportForJson> getAndDeserializeJson()
      throws IOException {
    final String json = tracker.getJson();
    LOG.info("Got JSON: {}", json);
    return (new ObjectMapper()).readValue(
        json, new TypeReference<Set<ReportForJson>>() {});
+++++++++++++++++++++++
  private Set<ReportForJson> getAndDeserializeJson()
      throws IOException {
    final String json = tracker.getJson();
    LOG.info("Got JSON: {}", json);
    return READER.readValue(json);
  public void testDeserializer() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(true);
    Assert.assertTrue(serializer.deserializeKV(in, key, value) > 0);

    Mockito.verify(in, Mockito.times(4)).readInt();
    Mockito.verify(in, Mockito.times(2)).readFully(Matchers.any(byte[].class),
                                                   Matchers.anyInt(), Matchers.anyInt());
+++++++++++++++++++++++
  public void testDeserializer() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(true);
    Assert.assertTrue(serializer.deserializeKV(in, key, value) > 0);

    Mockito.verify(in, Mockito.times(4)).readInt();
    Mockito.verify(in, Mockito.times(2)).readFully(any(byte[].class),
        anyInt(), anyInt());
  protected static void serializeAndDeserializePolicyManager(
      FederationPolicyManager wfp, Class policyManagerType,
      Class expAMRMProxyPolicy, Class expRouterPolicy) throws Exception {

    // serializeConf it in a context
    SubClusterPolicyConfiguration fpc = wfp.serializeConf();
    fpc.setType(policyManagerType.getCanonicalName());
    FederationPolicyInitializationContext context =
        new FederationPolicyInitializationContext();
    context.setSubClusterPolicyConfiguration(fpc);
    context
        .setFederationStateStoreFacade(FederationPoliciesTestUtil.initFacade());
    context.setFederationSubclusterResolver(
        FederationPoliciesTestUtil.initResolver());
    context.setHomeSubcluster(SubClusterId.newInstance("homesubcluster"));

    // based on the "context" created instantiate new class and use it
    Class c = Class.forName(wfp.getClass().getCanonicalName());
    FederationPolicyManager wfp2 = (FederationPolicyManager) c.newInstance();

    FederationAMRMProxyPolicy federationAMRMProxyPolicy =
        wfp2.getAMRMPolicy(context, null);

    FederationRouterPolicy federationRouterPolicy =
        wfp2.getRouterPolicy(context, null);

    Assert.assertEquals(federationAMRMProxyPolicy.getClass(),
        expAMRMProxyPolicy);

    Assert.assertEquals(federationRouterPolicy.getClass(), expRouterPolicy);
  }
+++++++++++++++++++++++
  protected static void serializeAndDeserializePolicyManager(
      FederationPolicyManager wfp, Class policyManagerType,
      Class expAMRMProxyPolicy, Class expRouterPolicy) throws Exception {

    // serializeConf it in a context
    SubClusterPolicyConfiguration fpc = wfp.serializeConf();
    fpc.setType(policyManagerType.getCanonicalName());
    FederationPolicyInitializationContext context =
        new FederationPolicyInitializationContext();
    context.setSubClusterPolicyConfiguration(fpc);
    context
        .setFederationStateStoreFacade(FederationPoliciesTestUtil.initFacade());
    context.setFederationSubclusterResolver(
        FederationPoliciesTestUtil.initResolver());
    context.setHomeSubcluster(SubClusterId.newInstance("homesubcluster"));

    // based on the "context" created instantiate new class and use it
    Class c = Class.forName(wfp.getClass().getCanonicalName());
    FederationPolicyManager wfp2 = (FederationPolicyManager) c.newInstance();

    FederationAMRMProxyPolicy federationAMRMProxyPolicy =
        wfp2.getAMRMPolicy(context, null);

    FederationRouterPolicy federationRouterPolicy =
        wfp2.getRouterPolicy(context, null);

    assertThat(federationAMRMProxyPolicy).
        isExactlyInstanceOf(expAMRMProxyPolicy);

    assertThat(federationRouterPolicy).isExactlyInstanceOf(expRouterPolicy);
  }
add: 3241, delete: 200, change: 2851, unhandled: 11 size_exceptions: 154 size_serialize: 4
-----------rel/submarine-0.2.0 vs release-0.1.0-----------
add: 148, delete: 11910, change: 0, unhandled: 13 size_exceptions: 0 size_serialize: 0
-----------release-0.1.0 vs release-0.1.1-----------
add: 0, delete: 0, change: 6, unhandled: 0 size_exceptions: 2 size_serialize: 0
-----------release-0.1.1 vs release-0.2.0-----------
add: 92, delete: 2, change: 66, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-0.2.0 vs release-0.2.1-----------
add: 0, delete: 0, change: 4, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.2.1 vs release-0.3.0-----------
add: 13, delete: 2, change: 74, unhandled: 0 size_exceptions: 4 size_serialize: 0
-----------release-0.3.0 vs release-0.3.1-----------
add: 0, delete: 0, change: 32, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.3.1 vs release-0.3.2-----------
add: 0, delete: 0, change: 18, unhandled: 0 size_exceptions: 2 size_serialize: 0
-----------release-0.3.2 vs release-0.4.0-----------
add: 9, delete: 0, change: 50, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.4.0 vs release-0.5.0-----------
  public void serialize(org.apache.hadoop.record.OutputArchive a_, String tag) throws java.io.IOException {
    if (!validate()) throw new java.io.IOException("All fields not set:");
    a_.startRecord(this,tag);
    a_.writeBool(mBoolVal,"BoolVal");
    bs_.clear(0);
    a_.writeByte(mByteVal,"ByteVal");
    bs_.clear(1);
    a_.writeInt(mIntVal,"IntVal");
    bs_.clear(2);
    a_.writeLong(mLongVal,"LongVal");
    bs_.clear(3);
    a_.writeFloat(mFloatVal,"FloatVal");
    bs_.clear(4);
    a_.writeDouble(mDoubleVal,"DoubleVal");
    bs_.clear(5);
    a_.writeString(mStringVal,"StringVal");
    bs_.clear(6);
    a_.writeBuffer(mBufferVal,"BufferVal");
    bs_.clear(7);
    {
      a_.startVector(mVectorVal,"VectorVal");
      int len1 = mVectorVal.size();
      for(int vidx1 = 0; vidx1<len1; vidx1++) {
        String e1 = (String) mVectorVal.get(vidx1);
        a_.writeString(e1,"e1");
      }
      a_.endVector(mVectorVal,"VectorVal");
    }
    bs_.clear(8);
    {
      a_.startMap(mMapVal,"MapVal");
      java.util.Set es1 = mMapVal.entrySet();
      for(java.util.Iterator midx1 = es1.iterator(); midx1.hasNext(); ) {
        java.util.Map.Entry me1 = (java.util.Map.Entry) midx1.next();
        String k1 = (String) me1.getKey();
        String v1 = (String) me1.getValue();
        a_.writeString(k1,"k1");
        a_.writeString(v1,"v1");
      }
      a_.endMap(mMapVal,"MapVal");
    }
    bs_.clear(9);
    a_.endRecord(this,tag);
  }
+++++++++++++++++++++++
  public void serialize(org.apache.hadoop.record.OutputArchive a_, String tag) throws java.io.IOException {
    if (!validate()) throw new java.io.IOException("All fields not set:");
    a_.startRecord(this,tag);
    a_.writeBool(mBoolVal,"BoolVal");
    bs_.clear(0);
    a_.writeByte(mByteVal,"ByteVal");
    bs_.clear(1);
    a_.writeInt(mIntVal,"IntVal");
    bs_.clear(2);
    a_.writeLong(mLongVal,"LongVal");
    bs_.clear(3);
    a_.writeFloat(mFloatVal,"FloatVal");
    bs_.clear(4);
    a_.writeDouble(mDoubleVal,"DoubleVal");
    bs_.clear(5);
    a_.writeString(mStringVal,"StringVal");
    bs_.clear(6);
    a_.writeBuffer(mBufferVal,"BufferVal");
    bs_.clear(7);
    {
      a_.startVector(mVectorVal,"VectorVal");
      int len1 = mVectorVal.size();
      for(int vidx1 = 0; vidx1<len1; vidx1++) {
        String e1 = (String) mVectorVal.get(vidx1);
        a_.writeString(e1,"e1");
      }
      a_.endVector(mVectorVal,"VectorVal");
    }
    bs_.clear(8);
    {
      a_.startMap(mMapVal,"MapVal");
      java.util.Set es1 = mMapVal.entrySet();
      for(java.util.Iterator midx1 = es1.iterator(); midx1.hasNext(); ) {
        java.util.Map.Entry me1 = (java.util.Map.Entry) midx1.next();
        String k1 = (String) me1.getKey();
        String v1 = (String) me1.getValue();
        a_.writeString(k1,"k1");
        a_.writeString(v1,"v1");
      }
      a_.endMap(mMapVal,"MapVal");
    }
    bs_.clear(9);
    a_.writeRecord(mRecordVal,"RecordVal");
    bs_.clear(10);
    a_.endRecord(this,tag);
  }
  public void deserialize(org.apache.hadoop.record.InputArchive a_, String tag) throws java.io.IOException {
    a_.startRecord(tag);
    mBoolVal=a_.readBool("BoolVal");
    bs_.set(0);
    mByteVal=a_.readByte("ByteVal");
    bs_.set(1);
    mIntVal=a_.readInt("IntVal");
    bs_.set(2);
    mLongVal=a_.readLong("LongVal");
    bs_.set(3);
    mFloatVal=a_.readFloat("FloatVal");
    bs_.set(4);
    mDoubleVal=a_.readDouble("DoubleVal");
    bs_.set(5);
    mStringVal=a_.readString("StringVal");
    bs_.set(6);
    mBufferVal=a_.readBuffer("BufferVal");
    bs_.set(7);
    {
      org.apache.hadoop.record.Index vidx1 = a_.startVector("VectorVal");
      mVectorVal=new java.util.ArrayList();
      for (; !vidx1.done(); vidx1.incr()) {
    String e1;
        e1=a_.readString("e1");
        mVectorVal.add(e1);
      }
    a_.endVector("VectorVal");
    }
    bs_.set(8);
    {
      org.apache.hadoop.record.Index midx1 = a_.startMap("MapVal");
      mMapVal=new java.util.TreeMap();
      for (; !midx1.done(); midx1.incr()) {
    String k1;
        k1=a_.readString("k1");
    String v1;
        v1=a_.readString("v1");
        mMapVal.put(k1,v1);
      }
    a_.endMap("MapVal");
    }
    bs_.set(9);
    a_.endRecord(tag);
}
+++++++++++++++++++++++
  public void deserialize(org.apache.hadoop.record.InputArchive a_, String tag) throws java.io.IOException {
    a_.startRecord(tag);
    mBoolVal=a_.readBool("BoolVal");
    bs_.set(0);
    mByteVal=a_.readByte("ByteVal");
    bs_.set(1);
    mIntVal=a_.readInt("IntVal");
    bs_.set(2);
    mLongVal=a_.readLong("LongVal");
    bs_.set(3);
    mFloatVal=a_.readFloat("FloatVal");
    bs_.set(4);
    mDoubleVal=a_.readDouble("DoubleVal");
    bs_.set(5);
    mStringVal=a_.readString("StringVal");
    bs_.set(6);
    mBufferVal=a_.readBuffer("BufferVal");
    bs_.set(7);
    {
      org.apache.hadoop.record.Index vidx1 = a_.startVector("VectorVal");
      mVectorVal=new java.util.ArrayList();
      for (; !vidx1.done(); vidx1.incr()) {
    String e1;
        e1=a_.readString("e1");
        mVectorVal.add(e1);
      }
    a_.endVector("VectorVal");
    }
    bs_.set(8);
    {
      org.apache.hadoop.record.Index midx1 = a_.startMap("MapVal");
      mMapVal=new java.util.TreeMap();
      for (; !midx1.done(); midx1.incr()) {
    String k1;
        k1=a_.readString("k1");
    String v1;
        v1=a_.readString("v1");
        mMapVal.put(k1,v1);
      }
    a_.endMap("MapVal");
    }
    bs_.set(9);
    mRecordVal= new org.apache.hadoop.record.test.RecRecord0();
    a_.readRecord(mRecordVal,"RecordVal");
    bs_.set(10);
    a_.endRecord(tag);
}
add: 25, delete: 0, change: 80, unhandled: 0 size_exceptions: 12 size_serialize: 2
-----------release-0.5.0 vs release-0.6.0-----------
  public void serialize(org.apache.hadoop.record.OutputArchive a_, String tag) throws java.io.IOException {
    if (!validate()) throw new java.io.IOException("All fields not set:");
    a_.startRecord(this,tag);
    a_.writeBool(mBoolVal,"BoolVal");
    bs_.clear(0);
    a_.writeByte(mByteVal,"ByteVal");
    bs_.clear(1);
    a_.writeInt(mIntVal,"IntVal");
    bs_.clear(2);
    a_.writeLong(mLongVal,"LongVal");
    bs_.clear(3);
    a_.writeFloat(mFloatVal,"FloatVal");
    bs_.clear(4);
    a_.writeDouble(mDoubleVal,"DoubleVal");
    bs_.clear(5);
    a_.writeString(mStringVal,"StringVal");
    bs_.clear(6);
    a_.writeBuffer(mBufferVal,"BufferVal");
    bs_.clear(7);
    {
      a_.startVector(mVectorVal,"VectorVal");
      int len1 = mVectorVal.size();
      for(int vidx1 = 0; vidx1<len1; vidx1++) {
        String e1 = (String) mVectorVal.get(vidx1);
        a_.writeString(e1,"e1");
      }
      a_.endVector(mVectorVal,"VectorVal");
    }
    bs_.clear(8);
    {
      a_.startMap(mMapVal,"MapVal");
      java.util.Set es1 = mMapVal.entrySet();
      for(java.util.Iterator midx1 = es1.iterator(); midx1.hasNext(); ) {
        java.util.Map.Entry me1 = (java.util.Map.Entry) midx1.next();
        String k1 = (String) me1.getKey();
        String v1 = (String) me1.getValue();
        a_.writeString(k1,"k1");
        a_.writeString(v1,"v1");
      }
      a_.endMap(mMapVal,"MapVal");
    }
    bs_.clear(9);
    a_.writeRecord(mRecordVal,"RecordVal");
    bs_.clear(10);
    a_.endRecord(this,tag);
  }
+++++++++++++++++++++++
  public void serialize(org.apache.hadoop.record.OutputArchive a_, String tag) throws java.io.IOException {
    if (!validate()) throw new java.io.IOException("All fields not set:");
    a_.startRecord(this,tag);
    a_.writeBool(mBoolVal,"BoolVal");
    bs_.clear(0);
    a_.writeByte(mByteVal,"ByteVal");
    bs_.clear(1);
    a_.writeInt(mIntVal,"IntVal");
    bs_.clear(2);
    a_.writeLong(mLongVal,"LongVal");
    bs_.clear(3);
    a_.writeFloat(mFloatVal,"FloatVal");
    bs_.clear(4);
    a_.writeDouble(mDoubleVal,"DoubleVal");
    bs_.clear(5);
    a_.writeString(mStringVal,"StringVal");
    bs_.clear(6);
    a_.writeBuffer(mBufferVal,"BufferVal");
    bs_.clear(7);
    {
      a_.startVector(mVectorVal,"VectorVal");
      int len1 = mVectorVal.size();
      for(int vidx1 = 0; vidx1<len1; vidx1++) {
        Text e1 = (Text) mVectorVal.get(vidx1);
        a_.writeString(e1,"e1");
      }
      a_.endVector(mVectorVal,"VectorVal");
    }
    bs_.clear(8);
    {
      a_.startMap(mMapVal,"MapVal");
      java.util.Set es1 = mMapVal.entrySet();
      for(java.util.Iterator midx1 = es1.iterator(); midx1.hasNext(); ) {
        java.util.Map.Entry me1 = (java.util.Map.Entry) midx1.next();
        Text k1 = (Text) me1.getKey();
        Text v1 = (Text) me1.getValue();
        a_.writeString(k1,"k1");
        a_.writeString(v1,"v1");
      }
      a_.endMap(mMapVal,"MapVal");
    }
    bs_.clear(9);
    a_.writeRecord(mRecordVal,"RecordVal");
    bs_.clear(10);
    a_.endRecord(this,tag);
  }
  public void deserialize(org.apache.hadoop.record.InputArchive a_, String tag) throws java.io.IOException {
    a_.startRecord(tag);
    mBoolVal=a_.readBool("BoolVal");
    bs_.set(0);
    mByteVal=a_.readByte("ByteVal");
    bs_.set(1);
    mIntVal=a_.readInt("IntVal");
    bs_.set(2);
    mLongVal=a_.readLong("LongVal");
    bs_.set(3);
    mFloatVal=a_.readFloat("FloatVal");
    bs_.set(4);
    mDoubleVal=a_.readDouble("DoubleVal");
    bs_.set(5);
    mStringVal=a_.readString("StringVal");
    bs_.set(6);
    mBufferVal=a_.readBuffer("BufferVal");
    bs_.set(7);
    {
      org.apache.hadoop.record.Index vidx1 = a_.startVector("VectorVal");
      mVectorVal=new java.util.ArrayList();
      for (; !vidx1.done(); vidx1.incr()) {
    String e1;
        e1=a_.readString("e1");
        mVectorVal.add(e1);
      }
    a_.endVector("VectorVal");
    }
    bs_.set(8);
    {
      org.apache.hadoop.record.Index midx1 = a_.startMap("MapVal");
      mMapVal=new java.util.TreeMap();
      for (; !midx1.done(); midx1.incr()) {
    String k1;
        k1=a_.readString("k1");
    String v1;
        v1=a_.readString("v1");
        mMapVal.put(k1,v1);
      }
    a_.endMap("MapVal");
    }
    bs_.set(9);
    mRecordVal= new org.apache.hadoop.record.test.RecRecord0();
    a_.readRecord(mRecordVal,"RecordVal");
    bs_.set(10);
    a_.endRecord(tag);
}
+++++++++++++++++++++++
  public void deserialize(org.apache.hadoop.record.InputArchive a_, String tag) throws java.io.IOException {
    a_.startRecord(tag);
    mBoolVal=a_.readBool("BoolVal");
    bs_.set(0);
    mByteVal=a_.readByte("ByteVal");
    bs_.set(1);
    mIntVal=a_.readInt("IntVal");
    bs_.set(2);
    mLongVal=a_.readLong("LongVal");
    bs_.set(3);
    mFloatVal=a_.readFloat("FloatVal");
    bs_.set(4);
    mDoubleVal=a_.readDouble("DoubleVal");
    bs_.set(5);
    mStringVal=a_.readString("StringVal");
    bs_.set(6);
    mBufferVal=a_.readBuffer("BufferVal");
    bs_.set(7);
    {
      org.apache.hadoop.record.Index vidx1 = a_.startVector("VectorVal");
      mVectorVal=new java.util.ArrayList();
      for (; !vidx1.done(); vidx1.incr()) {
    Text e1;
        e1=a_.readString("e1");
        mVectorVal.add(e1);
      }
    a_.endVector("VectorVal");
    }
    bs_.set(8);
    {
      org.apache.hadoop.record.Index midx1 = a_.startMap("MapVal");
      mMapVal=new java.util.TreeMap();
      for (; !midx1.done(); midx1.incr()) {
    Text k1;
        k1=a_.readString("k1");
    Text v1;
        v1=a_.readString("v1");
        mMapVal.put(k1,v1);
      }
    a_.endMap("MapVal");
    }
    bs_.set(9);
    mRecordVal= new org.apache.hadoop.record.test.RecRecord0();
    a_.readRecord(mRecordVal,"RecordVal");
    bs_.set(10);
    a_.endRecord(tag);
}
add: 18, delete: 0, change: 102, unhandled: 0 size_exceptions: 1 size_serialize: 2
-----------release-0.6.0 vs release-0.6.1-----------
add: 0, delete: 0, change: 5, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.6.1 vs release-0.6.2-----------
add: 0, delete: 0, change: 4, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.6.2 vs release-0.7.0-----------
add: 19, delete: 0, change: 80, unhandled: 0 size_exceptions: 7 size_serialize: 0
-----------release-0.7.0 vs release-0.7.1-----------
add: 0, delete: 0, change: 5, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.7.1 vs release-0.8.0-----------
add: 6, delete: 0, change: 300, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.8.0 vs release-0.9.0-----------
add: 21, delete: 2, change: 76, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.9.0 vs release-0.9.1-----------
add: 1, delete: 0, change: 6, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.9.1 vs release-0.9.2-----------
add: 6, delete: 0, change: 4, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.9.2 vs release-0.10.0-----------
add: 29, delete: 3, change: 107, unhandled: 0 size_exceptions: 4 size_serialize: 0
-----------release-0.10.0 vs release-0.10.1-----------
add: 5, delete: 0, change: 17, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-0.10.1 vs release-0.11.0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.11.0 vs release-0.11.1-----------
add: 31, delete: 5, change: 91, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.11.1 vs release-0.11.2-----------
add: 0, delete: 0, change: 3, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.11.2 vs release-0.12.0-----------
add: 33, delete: 11, change: 153, unhandled: 0 size_exceptions: 2 size_serialize: 0
-----------release-0.12.0 vs release-0.12.1-----------
add: 10, delete: 8, change: 29, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.12.1 vs release-0.12.3-----------
add: 0, delete: 0, change: 21, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.12.3 vs release-0.13.0-----------
add: 111, delete: 8, change: 331, unhandled: 0 size_exceptions: 4 size_serialize: 0
-----------release-0.13.0 vs release-0.13.1-----------
add: 0, delete: 0, change: 7, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.13.1 vs release-0.14.0-----------
add: 204, delete: 6, change: 372, unhandled: 0 size_exceptions: 27 size_serialize: 0
-----------release-0.14.0 vs release-0.14.1-----------
add: 0, delete: 0, change: 3, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.14.1 vs release-0.14.2-----------
add: 0, delete: 0, change: 23, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.14.2 vs release-0.14.3-----------
add: 0, delete: 0, change: 2, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.14.3 vs release-0.14.4-----------
add: 0, delete: 0, change: 1, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.14.4 vs release-0.15.0-----------
add: 96, delete: 13, change: 343, unhandled: 0 size_exceptions: 18 size_serialize: 0
-----------release-0.15.0 vs release-0.15.1-----------
add: 0, delete: 0, change: 11, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.15.1 vs release-0.15.2-----------
add: 0, delete: 0, change: 13, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.15.2 vs release-0.15.3-----------
add: 0, delete: 0, change: 4, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.15.3 vs release-0.16.0-----------
add: 192, delete: 68, change: 285, unhandled: 0 size_exceptions: 18 size_serialize: 0
-----------release-0.16.0 vs release-0.16.1-----------
add: 6, delete: 0, change: 64, unhandled: 0 size_exceptions: 3 size_serialize: 0
-----------release-0.16.1 vs release-0.16.2-----------
add: 3, delete: 210, change: 29, unhandled: 0 size_exceptions: 2 size_serialize: 0
-----------release-0.16.2 vs release-0.16.3-----------
add: 0, delete: 0, change: 14, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.16.3 vs release-0.16.4-----------
add: 0, delete: 0, change: 5, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.16.4 vs release-0.17.0-----------
add: 97, delete: 9, change: 283, unhandled: 0 size_exceptions: 4 size_serialize: 0
-----------release-0.17.0 vs release-0.17.1-----------
add: 0, delete: 0, change: 11, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.17.1 vs release-0.17.2-----------
add: 1, delete: 0, change: 10, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.17.2 vs release-0.18.0-----------
add: 569, delete: 486, change: 85, unhandled: 0 size_exceptions: 2 size_serialize: 0
-----------release-0.18.0 vs release-0.18.1-----------
add: 0, delete: 0, change: 10, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.18.1 vs release-0.18.2-----------
add: 3, delete: 0, change: 32, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.18.2 vs release-0.18.3-----------
add: 12, delete: 0, change: 43, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-0.18.3 vs release-0.19.0-----------
add: 961, delete: 181, change: 265, unhandled: 0 size_exceptions: 7 size_serialize: 0
-----------release-0.19.0 vs release-0.19.1-----------
add: 20, delete: 2, change: 89, unhandled: 0 size_exceptions: 2 size_serialize: 0
-----------release-0.19.1 vs release-0.19.2-----------
add: 3, delete: 0, change: 50, unhandled: 0 size_exceptions: 2 size_serialize: 0
-----------release-0.19.2 vs release-0.19.2-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.19.2-rc0 vs release-0.20.0-----------
add: 151, delete: 612, change: 321, unhandled: 0 size_exceptions: 15 size_serialize: 0
-----------release-0.20.0 vs release-0.20.1-----------
add: 46, delete: 2, change: 100, unhandled: 0 size_exceptions: 2 size_serialize: 0
-----------release-0.20.1 vs release-0.20.1-rc0-----------
add: 0, delete: 0, change: 4, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.20.1-rc0 vs release-0.20.1-rc1-----------
add: 0, delete: 0, change: 4, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.20.1-rc1 vs release-0.20.2-----------
add: 3, delete: 1, change: 71, unhandled: 0 size_exceptions: 26 size_serialize: 0
-----------release-0.20.2 vs release-0.20.2-rc1-----------
add: 0, delete: 0, change: 28, unhandled: 0 size_exceptions: 24 size_serialize: 0
-----------release-0.20.2-rc1 vs release-0.20.2-rc2-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.20.2-rc2 vs release-0.20.2-rc3-----------
add: 0, delete: 0, change: 12, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.20.2-rc3 vs release-0.20.2-rc4-----------
add: 0, delete: 0, change: 16, unhandled: 0 size_exceptions: 24 size_serialize: 0
-----------release-0.20.2-rc4 vs release-0.20.3-rc0-----------
add: 6, delete: 0, change: 42, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.20.3-rc0 vs release-0.20.3-rc1-----------
add: 0, delete: 0, change: 32, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.20.3-rc1 vs release-0.20.3-rc2-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.20.3-rc2 vs release-0.20.203.0-----------
add: 557, delete: 31, change: 412, unhandled: 0 size_exceptions: 62 size_serialize: 0
-----------release-0.20.203.0 vs release-0.20.203.0-rc0-----------
add: 0, delete: 2, change: 13, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.20.203.0-rc0 vs release-0.20.203.0-rc1-----------
add: 2, delete: 0, change: 13, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.20.203.0-rc1 vs release-0.20.204-rc1-----------
add: 15, delete: 0, change: 78, unhandled: 0 size_exceptions: 3 size_serialize: 0
-----------release-0.20.204-rc1 vs release-0.20.204.0-----------
add: 0, delete: 0, change: 5, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.20.204.0 vs release-0.20.204.0-rc0-----------
add: 0, delete: 0, change: 6, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.20.204.0-rc0 vs release-0.20.204.0-rc2-----------
add: 0, delete: 0, change: 1, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.20.204.0-rc2 vs release-0.20.204.0-rc3-----------
add: 0, delete: 0, change: 5, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.20.204.0-rc3 vs release-0.20.205.0-----------
add: 111, delete: 1, change: 189, unhandled: 0 size_exceptions: 4 size_serialize: 0
-----------release-0.20.205.0 vs release-0.20.205.0-rc1-----------
add: 1, delete: 7, change: 33, unhandled: 0 size_exceptions: 5 size_serialize: 0
-----------release-0.20.205.0-rc1 vs release-0.20.205.0-rc2-----------
add: 7, delete: 1, change: 33, unhandled: 0 size_exceptions: 5 size_serialize: 0
-----------release-0.20.205.0-rc2 vs release-0.21.0-----------
add: 2299, delete: 1970, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.21.0 vs release-0.21.0-rc0-----------
add: 618, delete: 2299, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.21.0-rc0 vs release-0.21.0-rc1-----------
add: 0, delete: 0, change: 5, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.21.0-rc1 vs release-0.21.0-rc2-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.21.0-rc2 vs release-0.22.0-----------
add: 2490, delete: 618, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.22.0 vs release-0.22.0-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.22.0-rc0 vs release-0.23.0-----------
add: 3790, delete: 2490, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.0 vs release-0.23.0-rc0-----------
add: 1, delete: 0, change: 19, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.0-rc0 vs release-0.23.0-rc1-----------
add: 0, delete: 1, change: 6, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.0-rc1 vs release-0.23.0-rc2-----------
add: 0, delete: 0, change: 13, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.0-rc2 vs release-0.23.1-----------
  static ByteBuffer serializeMetaData(int port) throws IOException {
    //TODO these bytes should be versioned
    DataOutputBuffer port_dob = new DataOutputBuffer();
    port_dob.writeInt(port);
    return ByteBuffer.wrap(port_dob.getData(), 0, port_dob.getLength());
  }

  /**
   * A helper function to deserialize the metadata returned by ShuffleHandler.
   * @param meta the metadata returned by the ShuffleHandler
   * @return the port the Shuffle Handler is listening on to serve shuffle data.
   */
+++++++++++++++++++++++
  public static ByteBuffer serializeMetaData(int port) throws IOException {
    //TODO these bytes should be versioned
    DataOutputBuffer port_dob = new DataOutputBuffer();
    port_dob.writeInt(port);
    return ByteBuffer.wrap(port_dob.getData(), 0, port_dob.getLength());
  }

  /**
   * A helper function to deserialize the metadata returned by ShuffleHandler.
   * @param meta the metadata returned by the ShuffleHandler
   * @return the port the Shuffle Handler is listening on to serve shuffle data.
   */
add: 805, delete: 462, change: 730, unhandled: 0 size_exceptions: 8 size_serialize: 1
-----------release-0.23.1 vs release-0.23.1-rc0-----------
add: 0, delete: 0, change: 22, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.1-rc0 vs release-0.23.1-rc1-----------
add: 4133, delete: 0, change: 16, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.1-rc1 vs release-0.23.1-rc2-----------
add: 0, delete: 4133, change: 6, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.1-rc2 vs release-0.23.2-rc0-----------
add: 17, delete: 2, change: 268, unhandled: 0 size_exceptions: 2 size_serialize: 0
-----------release-0.23.2-rc0 vs release-0.23.3-----------
add: 856, delete: 904, change: 331, unhandled: 0 size_exceptions: 8 size_serialize: 0
-----------release-0.23.3 vs release-0.23.3-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.3-rc0 vs release-0.23.4-----------
add: 5, delete: 0, change: 95, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-0.23.4 vs release-0.23.4-rc0-----------
add: 0, delete: 1, change: 17, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.4-rc0 vs release-0.23.4-rc1-----------
add: 1, delete: 0, change: 15, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.4-rc1 vs release-0.23.4-rc2-----------
add: 0, delete: 0, change: 2, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.4-rc2 vs release-0.23.5-----------
add: 15, delete: 326, change: 225, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.5 vs release-0.23.5-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.5-rc0 vs release-0.23.6-----------
add: 49, delete: 12, change: 159, unhandled: 0 size_exceptions: 2 size_serialize: 0
-----------release-0.23.6 vs release-0.23.6-rc0-----------
add: 0, delete: 0, change: 3, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.6-rc0 vs release-0.23.6-rc1-----------
add: 0, delete: 0, change: 3, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.6-rc1 vs release-0.23.6-rc1-old-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.6-rc1-old vs release-0.23.7-----------
add: 56, delete: 4, change: 249, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-0.23.7 vs release-0.23.7-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.7-rc0 vs release-0.23.8-----------
add: 12, delete: 0, change: 35, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-0.23.8 vs release-0.23.8-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.8-rc0 vs release-0.23.9-----------
add: 16, delete: 0, change: 22, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.9 vs release-0.23.9-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.9-rc0 vs release-0.23.10-----------
add: 11, delete: 2, change: 119, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-0.23.10 vs release-0.23.10-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.10-rc0 vs release-0.23.11-----------
add: 4, delete: 0, change: 54, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.11 vs release-0.23.11-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-0.23.11-rc0 vs release-1.0.0-----------
add: 1990, delete: 3924, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.0.0 vs release-1.0.0-rc2-----------
add: 0, delete: 1, change: 6, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.0.0-rc2 vs release-1.0.0-rc3-----------
add: 1, delete: 0, change: 6, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.0.0-rc3 vs release-1.0.1-----------
add: 79, delete: 1, change: 24, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.0.1 vs release-1.0.1-rc1-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.0.1-rc1 vs release-1.0.2-----------
add: 40, delete: 0, change: 28, unhandled: 0 size_exceptions: 2 size_serialize: 0
-----------release-1.0.2 vs release-1.0.2-rc1-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.0.2-rc1 vs release-1.0.2-rc2-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.0.2-rc2 vs release-1.0.3-----------
add: 3, delete: 0, change: 31, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-1.0.3 vs release-1.0.3-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.0.3-rc0 vs release-1.0.3-rc1-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.0.3-rc1 vs release-1.0.4-----------
add: 0, delete: 0, change: 4, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.0.4 vs release-1.0.4-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.0.4-rc0 vs release-1.1.0-----------
add: 99, delete: 3, change: 245, unhandled: 0 size_exceptions: 4 size_serialize: 0
-----------release-1.1.0 vs release-1.1.0-rc0-----------
add: 0, delete: 13, change: 90, unhandled: 0 size_exceptions: 3 size_serialize: 0
-----------release-1.1.0-rc0 vs release-1.1.0-rc1-----------
add: 3, delete: 0, change: 29, unhandled: 0 size_exceptions: 3 size_serialize: 0
-----------release-1.1.0-rc1 vs release-1.1.0-rc2-----------
add: 0, delete: 0, change: 12, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.1.0-rc2 vs release-1.1.0-rc3-----------
add: 1, delete: 0, change: 5, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.1.0-rc3 vs release-1.1.0-rc4-----------
add: 1, delete: 0, change: 8, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.1.0-rc4 vs release-1.1.0-rc5-----------
add: 8, delete: 0, change: 53, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.1.0-rc5 vs release-1.1.1-----------
add: 6, delete: 0, change: 30, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-1.1.1 vs release-1.1.1-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.1.1-rc0 vs release-1.1.2-----------
add: 5, delete: 0, change: 39, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-1.1.2 vs release-1.1.2-rc0-----------
add: 0, delete: 2, change: 19, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.1.2-rc0 vs release-1.1.2-rc1-----------
add: 0, delete: 0, change: 6, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.1.2-rc1 vs release-1.1.2-rc3-----------
add: 1, delete: 0, change: 9, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.1.2-rc3 vs release-1.1.2-rc4-----------
add: 1, delete: 0, change: 2, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.1.2-rc4 vs release-1.1.2-rc5-----------
add: 0, delete: 0, change: 2, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.1.2-rc5 vs release-1.2.0-----------
add: 134, delete: 1, change: 284, unhandled: 0 size_exceptions: 7 size_serialize: 0
-----------release-1.2.0 vs release-1.2.0-rc0-----------
add: 0, delete: 5, change: 44, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.2.0-rc0 vs release-1.2.0-rc1-----------
add: 5, delete: 0, change: 44, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.2.0-rc1 vs release-1.2.1-----------
add: 2, delete: 0, change: 23, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.2.1 vs release-1.2.1-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-1.2.1-rc0 vs release-2.0.0-alpha-----------
add: 4365, delete: 2353, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.0-alpha vs release-2.0.0-alpha-rc0-----------
add: 3, delete: 4, change: 43, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.0-alpha-rc0 vs release-2.0.0-alpha-rc1-----------
add: 4, delete: 3, change: 43, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.0-alpha-rc1 vs release-2.0.1-alpha-----------
add: 1, delete: 0, change: 30, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.1-alpha vs release-2.0.2-alpha-----------
  public Deserializer<Serializable> getDeserializer(Class<Serializable> c) {
    return new JavaSerializationDeserializer<Serializable>();
  }

  @InterfaceAudience.Private
+++++++++++++++++++++++
  public Deserializer<Serializable> getDeserializer(Class<Serializable> c) {
    return new JavaSerializationDeserializer<Serializable>();
  }

  @Override
  @InterfaceAudience.Private
  public Deserializer<T> getDeserializer(Class<T> c) {
    return new AvroDeserializer(c);
  }

  @InterfaceAudience.Private
+++++++++++++++++++++++
  public Deserializer<T> getDeserializer(Class<T> c) {
    return new AvroDeserializer(c);
  }

  @Override
  @InterfaceAudience.Private
  public void serialize(RecordOutput rout, String tag) throws IOException {
    // write out any header, version info, here
    rout.startRecord(this, tag);
    rout.writeString(name, tag);
    sTid.writeRest(rout, tag);
    rout.endRecord(this, tag);
  }

  /**
   * Deserialize the type information for a record
   */
+++++++++++++++++++++++
  public void serialize(RecordOutput rout, String tag) throws IOException {
    // write out any header, version info, here
    rout.startRecord(this, tag);
    rout.writeString(name, tag);
    sTid.writeRest(rout, tag);
    rout.endRecord(this, tag);
  }

  /**
   * Deserialize the type information for a record
   */
  @Override
  public void deserialize(RecordInput rin, String tag) throws IOException {
    // read in any header, version info 
    rin.startRecord(tag);
    // name
    this.name = rin.readString(tag);
    sTid.read(rin, tag);
    rin.endRecord(tag);
  }
  
  /**
   * This class doesn't implement Comparable as it's not meant to be used 
   * for anything besides de/serializing.
   * So we always throw an exception.
   * Not implemented. Always returns 0 if another RecordTypeInfo is passed in. 
   */
+++++++++++++++++++++++
  public void deserialize(RecordInput rin, String tag) throws IOException {
    // read in any header, version info 
    rin.startRecord(tag);
    // name
    this.name = rin.readString(tag);
    sTid.read(rin, tag);
    rin.endRecord(tag);
  }
  
  /**
   * This class doesn't implement Comparable as it's not meant to be used 
   * for anything besides de/serializing.
   * So we always throw an exception.
   * Not implemented. Always returns 0 if another RecordTypeInfo is passed in. 
   */
  @Override
add: 977, delete: 942, change: 1101, unhandled: 0 size_exceptions: 32 size_serialize: 4
-----------release-2.0.2-alpha vs release-2.0.2-alpha-rc0-----------
add: 18, delete: 19, change: 76, unhandled: 0 size_exceptions: 25 size_serialize: 0
-----------release-2.0.2-alpha-rc0 vs release-2.0.2-alpha-rc1-----------
add: 19, delete: 18, change: 76, unhandled: 0 size_exceptions: 25 size_serialize: 0
-----------release-2.0.2-alpha-rc1 vs release-2.0.2-alpha-rc2-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.2-alpha-rc2 vs release-2.0.3-alpha-----------
add: 254, delete: 387, change: 836, unhandled: 0 size_exceptions: 47 size_serialize: 0
-----------release-2.0.3-alpha vs release-2.0.3-alpha-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.3-alpha-rc0 vs release-2.0.4-alpha-----------
add: 15, delete: 8, change: 180, unhandled: 0 size_exceptions: 3 size_serialize: 0
-----------release-2.0.4-alpha vs release-2.0.4-alpha-rc0-----------
add: 0, delete: 0, change: 4, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.4-alpha-rc0 vs release-2.0.4-alpha-rc1-----------
add: 4275, delete: 0, change: 7, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.4-alpha-rc1 vs release-2.0.4-alpha-rc2-----------
add: 0, delete: 4275, change: 3, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.4-alpha-rc2 vs release-2.0.4.1-alpha-rc0-----------
add: 0, delete: 0, change: 2, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-2.0.4.1-alpha-rc0 vs release-2.0.5-alpha-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.5-alpha vs release-2.0.5-alpha-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.5-alpha-rc0 vs release-2.0.5-alpha-rc1-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.5-alpha-rc1 vs release-2.0.5-alpha-rc2-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.5-alpha-rc2 vs release-2.0.6-alpha-----------
add: 0, delete: 0, change: 6, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.6-alpha vs release-2.0.6-alpha-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.6-alpha-rc0 vs release-2.0.6-alpha-rc1-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.0.6-alpha-rc1 vs release-2.1.0-beta-----------
add: 608, delete: 221, change: 1278, unhandled: 0 size_exceptions: 177 size_serialize: 0
-----------release-2.1.0-beta vs release-2.1.0-beta-rc0-----------
add: 36, delete: 214, change: 440, unhandled: 0 size_exceptions: 28 size_serialize: 0
-----------release-2.1.0-beta-rc0 vs release-2.1.0-beta-rc1-----------
add: 214, delete: 36, change: 372, unhandled: 0 size_exceptions: 28 size_serialize: 0
-----------release-2.1.0-beta-rc1 vs release-2.1.0-beta-rc2-----------
add: 0, delete: 0, change: 93, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.1.0-beta-rc2 vs release-2.1.1-beta-rc0-----------
add: 46, delete: 7, change: 331, unhandled: 0 size_exceptions: 3 size_serialize: 0
-----------release-2.1.1-beta-rc0 vs release-2.1.1-rc0-----------
  public void testSerializeDeserialize() {
    // Serialize NfsTime
    NfsTime t1 = new NfsTime(1001);
    XDR xdr = new XDR();
    t1.serialize(xdr);
    
    // Deserialize it back
    NfsTime t2 = NfsTime.deserialize(xdr);
    
    // Ensure the NfsTimes are equal
    Assert.assertEquals(t1, t2);
+++++++++++++++++++++++
  public void testSerializeDeserialize() {
    // Serialize NfsTime
    NfsTime t1 = new NfsTime(1001);
    XDR xdr = new XDR();
    t1.serialize(xdr);
    
    // Deserialize it back
    NfsTime t2 = NfsTime.deserialize(xdr.asReadOnlyWrap());
    
    // Ensure the NfsTimes are equal
    Assert.assertEquals(t1, t2);
add: 21, delete: 11, change: 306, unhandled: 0 size_exceptions: 1 size_serialize: 1
-----------release-2.1.1-rc0 vs release-2.2.0-----------
add: 0, delete: 1, change: 1, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.2.0 vs release-2.2.0-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.2.0-rc0 vs release-2.2.1-rc0-----------
add: 1, delete: 0, change: 1, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.2.1-rc0 vs release-2.3.0-----------
  public void testSerializeAndDeserializeNull() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(null);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiate empty EnumSetWritable with no element type class providesd should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> nullFlagWritable = new EnumSetWritable<TestEnumSet>(
        null, TestEnumSet.class);

    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, nullFlagWritable, nullFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, null);
  }

+++++++++++++++++++++++
  public void testSerializeAndDeserializeNull() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(null);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception",
        gotException);

    EnumSetWritable<TestEnumSet> nullFlagWritable = 
        new EnumSetWritable<TestEnumSet>(null, TestEnumSet.class);

    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, nullFlagWritable, nullFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, null);
  }

  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiate empty EnumSetWritable with no element type class providesd should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = new EnumSetWritable<TestEnumSet>(
        emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
+++++++++++++++++++++++
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
add: 361, delete: 34, change: 901, unhandled: 0 size_exceptions: 47 size_serialize: 2
-----------release-2.3.0 vs release-2.3.0-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.3.0-rc0 vs release-2.4.0-----------
  public void serialize(XDR xdr) {
    xdr.writeInt(type);
    xdr.writeInt(mode);
    xdr.writeInt(nlink);
    xdr.writeInt(uid);
    xdr.writeInt(gid);
    xdr.writeLongAsHyper(size);
    xdr.writeLongAsHyper(used);
    xdr.writeInt(rdev.getSpecdata1());
    xdr.writeInt(rdev.getSpecdata2());
    xdr.writeLongAsHyper(fsid);
    xdr.writeLongAsHyper(fileid);
    atime.serialize(xdr);
    mtime.serialize(xdr);
    ctime.serialize(xdr);
  }
  
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    xdr.writeInt(type);
    xdr.writeInt(mode);
    xdr.writeInt(nlink);
    xdr.writeInt(uid);
    xdr.writeInt(gid);
    xdr.writeLongAsHyper(size);
    xdr.writeLongAsHyper(used);
    xdr.writeInt(rdev.getSpecdata1());
    xdr.writeInt(rdev.getSpecdata2());
    xdr.writeLongAsHyper(fsid);
    xdr.writeLongAsHyper(fileId);
    atime.serialize(xdr);
    mtime.serialize(xdr);
    ctime.serialize(xdr);
  }
  
  public static Nfs3FileAttributes deserialize(XDR xdr) {
    Nfs3FileAttributes attr = new Nfs3FileAttributes();
    attr.type = xdr.readInt();
    attr.mode = xdr.readInt();
    attr.nlink = xdr.readInt();
    attr.uid = xdr.readInt();
    attr.gid = xdr.readInt();
    attr.size = xdr.readHyper();
    attr.used = xdr.readHyper();
    // Ignore rdev
    xdr.readInt();
    xdr.readInt();
    attr.rdev = new Specdata3();
    attr.fsid = xdr.readHyper();
    attr.fileid = xdr.readHyper();
    attr.atime = NfsTime.deserialize(xdr);
    attr.mtime = NfsTime.deserialize(xdr);
    attr.ctime = NfsTime.deserialize(xdr);
    return attr;
  }
  
  @Override
+++++++++++++++++++++++
  public static Nfs3FileAttributes deserialize(XDR xdr) {
    Nfs3FileAttributes attr = new Nfs3FileAttributes();
    attr.type = xdr.readInt();
    attr.mode = xdr.readInt();
    attr.nlink = xdr.readInt();
    attr.uid = xdr.readInt();
    attr.gid = xdr.readInt();
    attr.size = xdr.readHyper();
    attr.used = xdr.readHyper();
    // Ignore rdev
    xdr.readInt();
    xdr.readInt();
    attr.rdev = new Specdata3();
    attr.fsid = xdr.readHyper();
    attr.fileId = xdr.readHyper();
    attr.atime = NfsTime.deserialize(xdr);
    attr.mtime = NfsTime.deserialize(xdr);
    attr.ctime = NfsTime.deserialize(xdr);
    return attr;
  }
  
  @Override
add: 276, delete: 17, change: 906, unhandled: 0 size_exceptions: 31 size_serialize: 2
-----------release-2.4.0 vs release-2.4.0-rc0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.4.0-rc0 vs release-2.4.1-----------
add: 5, delete: 0, change: 146, unhandled: 0 size_exceptions: 3 size_serialize: 0
-----------release-2.4.1 vs release-2.4.1-rc0-----------
add: 0, delete: 1, change: 2, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.4.1-rc0 vs release-2.4.1-rc1-----------
add: 1, delete: 0, change: 2, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.4.1-rc1 vs release-2.5.0-----------
  private void serializeLong(int times) {
    XDR w = new XDR();
    for (int i = 0; i < times; ++i)
      w.writeLongAsHyper(23);

    XDR r = w.asReadOnlyWrap();
    for (int i = 0; i < times; ++i)
      Assert.assertEquals(r.readHyper(), 23);
  }

  @Test
+++++++++++++++++++++++
  private void serializeLong(int times) {
    XDR w = new XDR();
    for (int i = 0; i < times; ++i)
      w.writeLongAsHyper(WRITE_VALUE);

    XDR r = w.asReadOnlyWrap();
    for (int i = 0; i < times; ++i)
      Assert.assertEquals(WRITE_VALUE, r.readHyper());
  }

  @Test
  private void serializeInt(int times) {
    XDR w = new XDR();
    for (int i = 0; i < times; ++i)
      w.writeInt(23);

    XDR r = w.asReadOnlyWrap();
    for (int i = 0; i < times; ++i)
      Assert.assertEquals(r.readInt(), 23);
  }

+++++++++++++++++++++++
  private void serializeInt(int times) {
    XDR w = new XDR();
    for (int i = 0; i < times; ++i)
      w.writeInt(WRITE_VALUE);

    XDR r = w.asReadOnlyWrap();
    for (int i = 0; i < times; ++i)
      Assert.assertEquals(
              WRITE_VALUE,r.readInt());
  }

  Token<DelegationTokenIdentifier> deserializeToken
          (String delegation,String nnId) throws IOException {
    final DataNode datanode = (DataNode) context.getAttribute("datanode");
    final Configuration conf = datanode.getConf();
    final Token<DelegationTokenIdentifier> token = new
            Token<DelegationTokenIdentifier>();
    token.decodeFromUrlString(delegation);
    URI nnUri = URI.create(HdfsConstants.HDFS_URI_SCHEME +
            "://" + nnId);
    boolean isHA = HAUtil.isLogicalUri(conf, nnUri);
    if (isHA) {
      token.setService(HAUtil.buildTokenServiceForLogicalUri(nnUri));
    } else {
      token.setService(SecurityUtil.buildTokenService(nnUri));
    }
    token.setKind(DelegationTokenIdentifier.HDFS_DELEGATION_KIND);
    return token;
  }

  /** Handle HTTP PUT request for the root. */
  @PUT
  @Path("/")
  @Consumes({"*/*"})
  @Produces({MediaType.APPLICATION_OCTET_STREAM, MediaType.APPLICATION_JSON})
+++++++++++++++++++++++
  Token<DelegationTokenIdentifier> deserializeToken
          (String delegation,String nnId) throws IOException {
    final DataNode datanode = (DataNode) context.getAttribute("datanode");
    final Configuration conf = datanode.getConf();
    final Token<DelegationTokenIdentifier> token = new
            Token<DelegationTokenIdentifier>();
    token.decodeFromUrlString(delegation);
    URI nnUri = URI.create(HdfsConstants.HDFS_URI_SCHEME +
            "://" + nnId);
    boolean isLogical = HAUtil.isLogicalUri(conf, nnUri);
    if (isLogical) {
      token.setService(HAUtil.buildTokenServiceForLogicalUri(nnUri));
    } else {
      token.setService(SecurityUtil.buildTokenService(nnUri));
    }
    token.setKind(DelegationTokenIdentifier.HDFS_DELEGATION_KIND);
    return token;
  }

  /** Handle HTTP PUT request for the root. */
  @PUT
  @Path("/")
  @Consumes({"*/*"})
  @Produces({MediaType.APPLICATION_OCTET_STREAM, MediaType.APPLICATION_JSON})
add: 246, delete: 41, change: 1067, unhandled: 0 size_exceptions: 32 size_serialize: 3
-----------release-2.5.0 vs release-2.5.0-rc0-----------
add: 0, delete: 0, change: 3, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.5.0-rc0 vs release-2.5.0-rc1-----------
add: 0, delete: 0, change: 3, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.5.0-rc1 vs release-2.5.0-rc2-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.5.0-rc2 vs release-2.5.1-----------
add: 0, delete: 0, change: 4, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.5.1 vs release-2.5.2-----------
add: 1, delete: 0, change: 4, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.5.2 vs release-2.5.2-RC0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.5.2-RC0 vs release-2.5.2-RC1-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.5.2-RC1 vs release-2.6.0-----------
  public void serialize(XDR xdr) {
    super.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
  Token<DelegationTokenIdentifier> deserializeToken
          (String delegation,String nnId) throws IOException {
    final DataNode datanode = (DataNode) context.getAttribute("datanode");
    final Configuration conf = datanode.getConf();
    final Token<DelegationTokenIdentifier> token = new
            Token<DelegationTokenIdentifier>();
    token.decodeFromUrlString(delegation);
    URI nnUri = URI.create(HdfsConstants.HDFS_URI_SCHEME +
            "://" + nnId);
    boolean isLogical = HAUtil.isLogicalUri(conf, nnUri);
    if (isLogical) {
      token.setService(HAUtil.buildTokenServiceForLogicalUri(nnUri));
    } else {
      token.setService(SecurityUtil.buildTokenService(nnUri));
    }
    token.setKind(DelegationTokenIdentifier.HDFS_DELEGATION_KIND);
    return token;
  }

  /** Handle HTTP PUT request for the root. */
  @PUT
  @Path("/")
  @Consumes({"*/*"})
  @Produces({MediaType.APPLICATION_OCTET_STREAM, MediaType.APPLICATION_JSON})
+++++++++++++++++++++++
  Token<DelegationTokenIdentifier> deserializeToken
          (String delegation,String nnId) throws IOException {
    final DataNode datanode = (DataNode) context.getAttribute("datanode");
    final Configuration conf = datanode.getConf();
    final Token<DelegationTokenIdentifier> token = new
            Token<DelegationTokenIdentifier>();
    token.decodeFromUrlString(delegation);
    URI nnUri = URI.create(HdfsConstants.HDFS_URI_SCHEME +
            "://" + nnId);
    boolean isLogical = HAUtil.isLogicalUri(conf, nnUri);
    if (isLogical) {
      token.setService(HAUtil.buildTokenServiceForLogicalUri(nnUri,
          HdfsConstants.HDFS_URI_SCHEME));
    } else {
      token.setService(SecurityUtil.buildTokenService(nnUri));
    }
    token.setKind(DelegationTokenIdentifier.HDFS_DELEGATION_KIND);
    return token;
  }

  /** Handle HTTP PUT request for the root. */
  @PUT
  @Path("/")
  @Consumes({"*/*"})
  @Produces({MediaType.APPLICATION_OCTET_STREAM, MediaType.APPLICATION_JSON})
add: 574, delete: 88, change: 1130, unhandled: 0 size_exceptions: 51 size_serialize: 2
-----------release-2.6.0 vs release-2.6.0-rc0-----------
add: 0, delete: 4, change: 32, unhandled: 0 size_exceptions: 3 size_serialize: 0
-----------release-2.6.0-rc0 vs release-2.6.0-rc1-----------
add: 4, delete: 0, change: 32, unhandled: 0 size_exceptions: 3 size_serialize: 0
-----------release-2.6.0-rc1 vs release-2.6.1-----------
add: 35, delete: 4, change: 365, unhandled: 0 size_exceptions: 9 size_serialize: 0
-----------release-2.6.1 vs release-2.6.1-RC0-----------
add: 0, delete: 4, change: 35, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.6.1-RC0 vs release-2.6.1-RC1-----------
add: 4, delete: 0, change: 35, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.6.1-RC1 vs release-2.6.2-----------
add: 0, delete: 0, change: 37, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.6.2 vs release-2.6.2-RC0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.6.2-RC0 vs release-2.6.3-----------
add: 3, delete: 0, change: 60, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.6.3 vs release-2.6.3-RC0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.6.3-RC0 vs release-2.6.3-RC0.1-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.6.3-RC0.1 vs release-2.6.3-RC1-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.6.3-RC1 vs release-2.6.4-RC0-----------
add: 4, delete: 0, change: 101, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.6.4-RC0 vs release-2.6.5-RC0-----------
add: 3, delete: 0, change: 123, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-2.6.5-RC0 vs release-2.6.5-RC1-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.6.5-RC1 vs release-2.7.0-----------
  public static Nfs3FileAttributes deserialize(XDR xdr) {
    Nfs3FileAttributes attr = new Nfs3FileAttributes();
    attr.type = xdr.readInt();
    attr.mode = xdr.readInt();
    attr.nlink = xdr.readInt();
    attr.uid = xdr.readInt();
    attr.gid = xdr.readInt();
    attr.size = xdr.readHyper();
    attr.used = xdr.readHyper();
    // Ignore rdev
    xdr.readInt();
    xdr.readInt();
    attr.rdev = new Specdata3();
    attr.fsid = xdr.readHyper();
    attr.fileId = xdr.readHyper();
    attr.atime = NfsTime.deserialize(xdr);
    attr.mtime = NfsTime.deserialize(xdr);
    attr.ctime = NfsTime.deserialize(xdr);
    return attr;
  }
  
  @Override
+++++++++++++++++++++++
  public static Nfs3FileAttributes deserialize(XDR xdr) {
    Nfs3FileAttributes attr = new Nfs3FileAttributes();
    attr.type = xdr.readInt();
    attr.mode = xdr.readInt();
    attr.nlink = xdr.readInt();
    attr.uid = xdr.readInt();
    attr.gid = xdr.readInt();
    attr.size = xdr.readHyper();
    attr.used = xdr.readHyper();
    attr.rdev = new Specdata3(xdr.readInt(), xdr.readInt());
    attr.fsid = xdr.readHyper();
    attr.fileId = xdr.readHyper();
    attr.atime = NfsTime.deserialize(xdr);
    attr.mtime = NfsTime.deserialize(xdr);
    attr.ctime = NfsTime.deserialize(xdr);
    return attr;
  }
  
  @Override
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(), name.length());
    xdr.writeInt(mode);
    objAttr.serialize(xdr);
  }
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8), name.length());
    xdr.writeInt(mode);
    objAttr.serialize(xdr);
  }
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.length());
    xdr.writeFixedOpaque(fromName.getBytes(), fromName.length());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.length());
    xdr.writeFixedOpaque(fromName.getBytes(Charsets.UTF_8), fromName.length());
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
    objAttr.serialize(xdr);
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
    objAttr.serialize(xdr);
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(), name.length());
    objAttr.serialize(xdr);
    if (spec != null) {
      xdr.writeInt(spec.getSpecdata1());
      xdr.writeInt(spec.getSpecdata2());
    }
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8), name.length());
    objAttr.serialize(xdr);
    if (spec != null) {
      xdr.writeInt(spec.getSpecdata1());
      xdr.writeInt(spec.getSpecdata2());
    }
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
  public void serialize(XDR xdr) {
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.getBytes().length);
    xdr.writeFixedOpaque(fromName.getBytes());
    toDirHandle.serialize(xdr);
    xdr.writeInt(toName.getBytes().length);
    xdr.writeFixedOpaque(toName.getBytes());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(fromName.getBytes(Charsets.UTF_8));
    toDirHandle.serialize(xdr);
    xdr.writeInt(toName.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(toName.getBytes(Charsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes().length);
    xdr.writeFixedOpaque(name.getBytes());
    symAttr.serialize(xdr);
    xdr.writeInt(symData.getBytes().length);
    xdr.writeFixedOpaque(symData.getBytes());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
    symAttr.serialize(xdr);
    xdr.writeInt(symData.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(symData.getBytes(Charsets.UTF_8));
add: 339, delete: 52, change: 1473, unhandled: 0 size_exceptions: 103 size_serialize: 10
-----------release-2.7.0 vs release-2.7.0-RC0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.7.0-RC0 vs release-2.7.1-----------
add: 10, delete: 0, change: 254, unhandled: 0 size_exceptions: 3 size_serialize: 0
-----------release-2.7.1 vs release-2.7.1-RC0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.7.1-RC0 vs release-2.7.2-RC0-----------
add: 19, delete: 9, change: 254, unhandled: 0 size_exceptions: 3 size_serialize: 0
-----------release-2.7.2-RC0 vs release-2.7.2-RC1-----------
add: 0, delete: 0, change: 13, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.7.2-RC1 vs release-2.7.2-RC2-----------
add: 1, delete: 0, change: 33, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.7.2-RC2 vs release-2.7.3-RC0-----------
add: 6, delete: 0, change: 333, unhandled: 0 size_exceptions: 6 size_serialize: 0
-----------release-2.7.3-RC0 vs release-2.7.3-RC1-----------
add: 0, delete: 0, change: 6, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.7.3-RC1 vs release-2.7.3-RC2-----------
add: 0, delete: 1, change: 1, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.7.3-RC2 vs release-2.7.4-RC0-----------
add: 25, delete: 1, change: 343, unhandled: 0 size_exceptions: 5 size_serialize: 0
-----------release-2.7.4-RC0 vs release-2.7.5-RC0-----------
add: 4, delete: 0, change: 72, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-2.7.5-RC0 vs release-2.7.5-RC1-----------
add: 0, delete: 0, change: 2, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.7.5-RC1 vs release-2.7.6-RC0-----------
add: 5, delete: 3, change: 72, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-2.7.6-RC0 vs release-2.7.7-RC0-----------
add: 0, delete: 0, change: 18, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.7.7-RC0 vs release-2.8.0-RC0-----------
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
+++++++++++++++++++++++
  public void testSerializeAndDeserializeEmpty() throws IOException {

    boolean gotException = false;
    try {
      new EnumSetWritable<TestEnumSet>(emptyFlag);
    } catch (RuntimeException e) {
      gotException = true;
    }

    assertTrue(
        "Instantiation of empty EnumSetWritable with no element type class "
        + "provided should throw exception.",
        gotException);

    EnumSetWritable<TestEnumSet> emptyFlagWritable = 
        new EnumSetWritable<TestEnumSet>(emptyFlag, TestEnumSet.class);
    DataOutputBuffer out = new DataOutputBuffer();
    ObjectWritable.writeObject(out, emptyFlagWritable, emptyFlagWritable
        .getClass(), null);
    DataInputBuffer in = new DataInputBuffer();
    in.reset(out.getData(), out.getLength());
    EnumSet<TestEnumSet> read = ((EnumSetWritable<TestEnumSet>) ObjectWritable
        .readObject(in, null)).get();
    assertEquals(read, emptyFlag);
  }

  @SuppressWarnings("unchecked")
  @Test
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8), name.length());
    xdr.writeInt(mode);
    objAttr.serialize(xdr);
  }
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8), name.length());
    xdr.writeInt(mode);
    objAttr.serialize(xdr);
  }
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.length());
    xdr.writeFixedOpaque(fromName.getBytes(Charsets.UTF_8), fromName.length());
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.length());
    xdr.writeFixedOpaque(fromName.getBytes(StandardCharsets.UTF_8),
        fromName.length());
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
    objAttr.serialize(xdr);
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
    objAttr.serialize(xdr);
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8), name.length());
    objAttr.serialize(xdr);
    if (spec != null) {
      xdr.writeInt(spec.getSpecdata1());
      xdr.writeInt(spec.getSpecdata2());
    }
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.length());
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8), name.length());
    objAttr.serialize(xdr);
    if (spec != null) {
      xdr.writeInt(spec.getSpecdata1());
      xdr.writeInt(spec.getSpecdata2());
    }
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(fromName.getBytes(Charsets.UTF_8));
    toDirHandle.serialize(xdr);
    xdr.writeInt(toName.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(toName.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    fromDirHandle.serialize(xdr);
    xdr.writeInt(fromName.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(fromName.getBytes(StandardCharsets.UTF_8));
    toDirHandle.serialize(xdr);
    xdr.writeInt(toName.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(toName.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(Charsets.UTF_8));
    symAttr.serialize(xdr);
    xdr.writeInt(symData.getBytes(Charsets.UTF_8).length);
    xdr.writeFixedOpaque(symData.getBytes(Charsets.UTF_8));
+++++++++++++++++++++++
  public void serialize(XDR xdr) {
    handle.serialize(xdr);
    xdr.writeInt(name.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(name.getBytes(StandardCharsets.UTF_8));
    symAttr.serialize(xdr);
    xdr.writeInt(symData.getBytes(StandardCharsets.UTF_8).length);
    xdr.writeFixedOpaque(symData.getBytes(StandardCharsets.UTF_8));
  public void testDeserializeHAToken() throws IOException {
    Configuration conf = DFSTestUtil.newHAConfiguration(LOGICAL_NAME);
    final Token<DelegationTokenIdentifier> token = new
        Token<DelegationTokenIdentifier>();
    QueryStringDecoder decoder = new QueryStringDecoder(
      WebHdfsHandler.WEBHDFS_PREFIX + "/?"
      + NamenodeAddressParam.NAME + "=" + LOGICAL_NAME + "&"
      + DelegationParam.NAME + "=" + token.encodeToUrlString());
    ParameterParser testParser = new ParameterParser(decoder, conf);
    final Token<DelegationTokenIdentifier> tok2 = testParser.delegationToken();
    Assert.assertTrue(HAUtil.isTokenForLogicalUri(tok2));
  }

  @Test
+++++++++++++++++++++++
  public void testDeserializeHAToken() throws IOException {
    Configuration conf = DFSTestUtil.newHAConfiguration(LOGICAL_NAME);
    final Token<DelegationTokenIdentifier> token = new
        Token<DelegationTokenIdentifier>();
    QueryStringDecoder decoder = new QueryStringDecoder(
      WebHdfsHandler.WEBHDFS_PREFIX + "/?"
      + NamenodeAddressParam.NAME + "=" + LOGICAL_NAME + "&"
      + DelegationParam.NAME + "=" + token.encodeToUrlString());
    ParameterParser testParser = new ParameterParser(decoder, conf);
    final Token<DelegationTokenIdentifier> tok2 = testParser.delegationToken();
    Assert.assertTrue(HAUtilClient.isTokenForLogicalUri(tok2));
  }

  @Test
add: 980, delete: 298, change: 2323, unhandled: 0 size_exceptions: 119 size_serialize: 11
-----------release-2.8.0-RC0 vs release-2.8.0-RC1-----------
add: 0, delete: 0, change: 1, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.8.0-RC1 vs release-2.8.0-RC2-----------
add: 48, delete: 5, change: 45, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.8.0-RC2 vs release-2.8.0-RC3-----------
add: 0, delete: 0, change: 1, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.8.0-RC3 vs release-2.8.2-RC0-----------
add: 32, delete: 6, change: 511, unhandled: 0 size_exceptions: 11 size_serialize: 0
-----------release-2.8.2-RC0 vs release-2.8.2-RC1-----------
add: 1, delete: 0, change: 14, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-2.8.2-RC1 vs release-2.8.3-RC0-----------
add: 8, delete: 0, change: 155, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-2.8.3-RC0 vs release-2.8.4-RC0-----------
add: 5, delete: 4, change: 180, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-2.8.4-RC0 vs release-2.8.5-RC0-----------
add: 3, delete: 0, change: 48, unhandled: 0 size_exceptions: 6 size_serialize: 0
-----------release-2.8.5-RC0 vs release-2.9.0-RC0-----------
add: 1339, delete: 78, change: 1920, unhandled: 0 size_exceptions: 74 size_serialize: 0
-----------release-2.9.0-RC0 vs release-2.9.0-RC1-----------
add: 0, delete: 0, change: 7, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.9.0-RC1 vs release-2.9.0-RC2-----------
add: 0, delete: 0, change: 7, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.9.0-RC2 vs release-2.9.0-RC3-----------
add: 0, delete: 0, change: 1, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.9.0-RC3 vs release-2.9.1-RC0-----------
add: 281, delete: 154, change: 242, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-2.9.1-RC0 vs release-2.9.2-RC0-----------
add: 33, delete: 1, change: 297, unhandled: 0 size_exceptions: 11 size_serialize: 0
-----------release-2.9.2-RC0 vs release-2.10.0-RC0-----------
add: 435, delete: 96, change: 726, unhandled: 0 size_exceptions: 32 size_serialize: 0
-----------release-2.10.0-RC0 vs release-2.10.0-RC1-----------
add: 4, delete: 0, change: 5, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-2.10.0-RC1 vs release-3.0.0-RC0-----------
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").getTextValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
+++++++++++++++++++++++
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").textValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
add: 753, delete: 928, change: 2429, unhandled: 1 size_exceptions: 76 size_serialize: 1
-----------release-3.0.0-RC0 vs release-3.0.0-RC1-----------
add: 4, delete: 0, change: 52, unhandled: 0 size_exceptions: 1 size_serialize: 0
-----------release-3.0.0-RC1 vs release-3.0.0-alpha1-RC0-----------
  public void testDeserializerNoData() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(false);
    Assert.assertEquals(0, serializer.deserializeKV(in, key, value));
  }

  @Test
+++++++++++++++++++++++
  public void testDeserializerNoData() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(false);
    Assert.assertEquals(0, serializer.deserializeKV(in, key, value));
  }

  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").textValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
+++++++++++++++++++++++
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").getTextValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
add: 268, delete: 1398, change: 2897, unhandled: 0 size_exceptions: 132 size_serialize: 2
-----------release-3.0.0-alpha1-RC0 vs release-3.0.0-alpha2-RC0-----------
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").getTextValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
+++++++++++++++++++++++
  public StatePair deserialize(JsonParser parser, 
                               DeserializationContext context)
  throws IOException, JsonProcessingException {
    ObjectMapper mapper = (ObjectMapper) parser.getCodec();
    // set the state-pair object tree
    ObjectNode statePairObject = (ObjectNode) mapper.readTree(parser);
    Class<?> stateClass = null;
    
    try {
      stateClass = 
        Class.forName(statePairObject.get("className").textValue().trim());
    } catch (ClassNotFoundException cnfe) {
      throw new RuntimeException("Invalid classname!", cnfe);
    }
    
    String stateJsonString = statePairObject.get("state").toString();
    State state = (State) mapper.readValue(stateJsonString, stateClass);
    
    return new StatePair(state);
add: 406, delete: 162, change: 1556, unhandled: 0 size_exceptions: 48 size_serialize: 1
-----------release-3.0.0-alpha2-RC0 vs release-3.0.0-alpha4-RC0-----------
add: 238, delete: 45, change: 1392, unhandled: 0 size_exceptions: 54 size_serialize: 0
-----------release-3.0.0-alpha4-RC0 vs release-3.0.0-beta1-RC0-----------
  public void testDeserializerNoData() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(false);
    Assert.assertEquals(0, serializer.deserializeKV(in, key, value));
  }

+++++++++++++++++++++++
  public void testDeserializerNoData() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(false);
    Assert.assertEquals(0, serializer.deserializeKV(in, key, value));
  }

  @Test
add: 465, delete: 82, change: 1464, unhandled: 2 size_exceptions: 31 size_serialize: 1
-----------release-3.0.0-beta1-RC0 vs release-3.0.1-RC0-----------
add: 376, delete: 15, change: 954, unhandled: 2 size_exceptions: 73 size_serialize: 0
-----------release-3.0.1-RC0 vs release-3.0.1-RC1-----------
add: 1, delete: 4, change: 28, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-3.0.1-RC1 vs release-3.0.2-RC0-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-3.0.2-RC0 vs release-3.0.2-RC1-----------
add: 0, delete: 0, change: 0, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-3.0.2-RC1 vs release-3.0.3-RC0-----------
add: 287, delete: 200, change: 350, unhandled: 1 size_exceptions: 13 size_serialize: 0
-----------release-3.0.3-RC0 vs release-3.1.0-RC0-----------
  public boolean deserialize(XDR xdr) {
    if (!XDR.verifyLength(xdr, 32)) {
      return false;
    }
    int size = xdr.readInt();
    handle = xdr.readFixedOpaque(size);
    fileId = bytesToLong(handle);
    return true;
  }
  
+++++++++++++++++++++++
  public boolean deserialize(XDR xdr) {
    if (!XDR.verifyLength(xdr, 32)) {
      return false;
    }
    int size = xdr.readInt();
    handle = xdr.readFixedOpaque(size);
    fileId = bytesToLong(handle, 0);
    namenodeId = bytesToInt(handle, 8);
    return true;
  }
  
  private Set<ReportForJson> getAndDeserializeJson()
      throws IOException {
    final String json = tracker.getJson();
    LOG.info("Got JSON: {}", json);
    return (new ObjectMapper()).readValue(
        json, new TypeReference<Set<ReportForJson>>() {});
+++++++++++++++++++++++
  private Set<ReportForJson> getAndDeserializeJson()
      throws IOException {
    final String json = tracker.getJson();
    LOG.info("Got JSON: {}", json);
    return READER.readValue(json);
add: 675, delete: 179, change: 1164, unhandled: 2 size_exceptions: 62 size_serialize: 2
-----------release-3.1.0-RC0 vs release-3.1.0-RC1-----------
add: 30, delete: 3, change: 59, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-3.1.0-RC1 vs release-3.1.1-RC0-----------
add: 113, delete: 18, change: 676, unhandled: 2 size_exceptions: 32 size_serialize: 0
-----------release-3.1.1-RC0 vs release-3.1.2-RC0-----------
add: 57, delete: 5, change: 552, unhandled: 0 size_exceptions: 39 size_serialize: 0
-----------release-3.1.2-RC0 vs release-3.1.2-RC1-----------
add: 0, delete: 5, change: 2, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-3.1.2-RC1 vs release-3.1.3-RC0-----------
add: 55, delete: 1, change: 506, unhandled: 3 size_exceptions: 5 size_serialize: 0
-----------release-3.1.3-RC0 vs release-3.2.0-RC0-----------
add: 439, delete: 86, change: 1624, unhandled: 3 size_exceptions: 46 size_serialize: 0
-----------release-3.2.0-RC0 vs release-3.2.0-RC1-----------
add: 2, delete: 1, change: 26, unhandled: 0 size_exceptions: 0 size_serialize: 0
-----------release-3.2.0-RC1 vs release-3.2.1-RC0-----------
  public static Map<String, String> deserializeAclSpec(final String aclSpecString) {
    final Map<String, String> aclEntries  = new HashMap<>();
    final String[] aclArray = aclSpecString.split(AbfsHttpConstants.COMMA);
    for (String acl : aclArray) {
      int idx = acl.lastIndexOf(AbfsHttpConstants.COLON);
      aclEntries.put(acl.substring(0, idx), acl.substring(idx + 1));
    }
    return aclEntries;
  }

+++++++++++++++++++++++
  public static Map<String, String> deserializeAclSpec(final String aclSpecString) throws AzureBlobFileSystemException {
    final Map<String, String> aclEntries  = new HashMap<>();
    final String[] aceArray = aclSpecString.split(AbfsHttpConstants.COMMA);
    for (String ace : aceArray) {
      int idx = ace.lastIndexOf(AbfsHttpConstants.COLON);
      final String key = ace.substring(0, idx);
      final String val = ace.substring(idx + 1);
      if (aclEntries.containsKey(key)) {
        throw new InvalidAclOperationException("Duplicate acl entries are not allowed.");
      }
      aclEntries.put(key, val);
    }
    return aclEntries;
  }

add: 123, delete: 9, change: 787, unhandled: 3 size_exceptions: 34 size_serialize: 1
-----------release-3.2.1-RC0 vs remove-ozone-----------
  public void testDeserializer() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(true);
    Assert.assertTrue(serializer.deserializeKV(in, key, value) > 0);

    Mockito.verify(in, Mockito.times(4)).readInt();
    Mockito.verify(in, Mockito.times(2)).readFully(Matchers.any(byte[].class),
                                                   Matchers.anyInt(), Matchers.anyInt());
+++++++++++++++++++++++
  public void testDeserializer() throws IOException {
    final DataInputStream in = Mockito.mock(DataInputStream.class);
    Mockito.when(in.hasUnReadData()).thenReturn(true);
    Assert.assertTrue(serializer.deserializeKV(in, key, value) > 0);

    Mockito.verify(in, Mockito.times(4)).readInt();
    Mockito.verify(in, Mockito.times(2)).readFully(any(byte[].class),
        anyInt(), anyInt());
  protected static void serializeAndDeserializePolicyManager(
      FederationPolicyManager wfp, Class policyManagerType,
      Class expAMRMProxyPolicy, Class expRouterPolicy) throws Exception {

    // serializeConf it in a context
    SubClusterPolicyConfiguration fpc = wfp.serializeConf();
    fpc.setType(policyManagerType.getCanonicalName());
    FederationPolicyInitializationContext context =
        new FederationPolicyInitializationContext();
    context.setSubClusterPolicyConfiguration(fpc);
    context
        .setFederationStateStoreFacade(FederationPoliciesTestUtil.initFacade());
    context.setFederationSubclusterResolver(
        FederationPoliciesTestUtil.initResolver());
    context.setHomeSubcluster(SubClusterId.newInstance("homesubcluster"));

    // based on the "context" created instantiate new class and use it
    Class c = Class.forName(wfp.getClass().getCanonicalName());
    FederationPolicyManager wfp2 = (FederationPolicyManager) c.newInstance();

    FederationAMRMProxyPolicy federationAMRMProxyPolicy =
        wfp2.getAMRMPolicy(context, null);

    FederationRouterPolicy federationRouterPolicy =
        wfp2.getRouterPolicy(context, null);

    Assert.assertEquals(federationAMRMProxyPolicy.getClass(),
        expAMRMProxyPolicy);

    Assert.assertEquals(federationRouterPolicy.getClass(), expRouterPolicy);
  }
+++++++++++++++++++++++
  protected static void serializeAndDeserializePolicyManager(
      FederationPolicyManager wfp, Class policyManagerType,
      Class expAMRMProxyPolicy, Class expRouterPolicy) throws Exception {

    // serializeConf it in a context
    SubClusterPolicyConfiguration fpc = wfp.serializeConf();
    fpc.setType(policyManagerType.getCanonicalName());
    FederationPolicyInitializationContext context =
        new FederationPolicyInitializationContext();
    context.setSubClusterPolicyConfiguration(fpc);
    context
        .setFederationStateStoreFacade(FederationPoliciesTestUtil.initFacade());
    context.setFederationSubclusterResolver(
        FederationPoliciesTestUtil.initResolver());
    context.setHomeSubcluster(SubClusterId.newInstance("homesubcluster"));

    // based on the "context" created instantiate new class and use it
    Class c = Class.forName(wfp.getClass().getCanonicalName());
    FederationPolicyManager wfp2 = (FederationPolicyManager) c.newInstance();

    FederationAMRMProxyPolicy federationAMRMProxyPolicy =
        wfp2.getAMRMPolicy(context, null);

    FederationRouterPolicy federationRouterPolicy =
        wfp2.getRouterPolicy(context, null);

    assertThat(federationAMRMProxyPolicy).
        isExactlyInstanceOf(expAMRMProxyPolicy);

    assertThat(federationRouterPolicy).isExactlyInstanceOf(expRouterPolicy);
  }
add: 949, delete: 162, change: 2183, unhandled: 4 size_exceptions: 80 size_serialize: 2
-----------remove-ozone vs submarine-0.2.0-RC0-----------
add: 1397, delete: 330, change: 1207, unhandled: 10 size_exceptions: 39 size_serialize: 0
